/********************************************************************************
 * PROYECTO: Sistema de Control SEDA 
 * DISPOSITIVO: NXP LPC1768
 ********************************************************************************/

#include <LPC17xx.H>
#include <glcd.h>
#include <TouchPanel.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "uart.h" /* Librería RFID */
#include <TCS34725.h>



#define F_sample 8000
#define N_muestras 12000 
#define UMBRAL_DETECCION 40  

/* --- DEFINICIONES DE TIMING --- */
#define T_REFRESCO_SENSORES_MS  200
#define T_REFRESCO_TOUCH_MS     50

/* --- DEFINICIONES DE HARDWARE Y RELOJES --- */
#define F_cpu 100e6                      
#define F_pclk F_cpu/4                  
#define F_wdclk F_pclk/4                
#define Fpclk_pwm 25e6                  
#define Tpwm  1e-3                      
#define F_muestreo 50

/* --- CONSTANTES RTC --- */
#define PCRTC 9                         
#define CLKEN 0                         
#define RTCIF 0                         
#define IMSEC 0                         
#define CCALEN 4  

#define PIN_IR_VERDE    (1 << 14) // P1.14
#define PIN_IR_ROSA     (1 << 15) // P1.15

/* --- ESTRUCTURAS Y TIPOS --- */
struct t_screenZone {
    uint16_t x; uint16_t y;
    uint16_t size_x; uint16_t size_y;
    uint8_t  pressed;
};

typedef enum { 
    ESTADO_MENU_PRINCIPAL, 
    ESTADO_MODO_NORMAL, 
    ESTADO_MODO_CONFIG,
    ESTADO_CONFIG_VERDE,    // Nuevo: Submenú para grabar Verde
    ESTADO_CONFIG_ROSA,     // Nuevo: Submenú para grabar Rosa
    ESTADO_AJUSTE_RTC,          
    ESTADO_TECLADO            
} t_EstadoSistema;

typedef enum {
    ESPERA_TRAMA,
    VALIDAR_CABECERA,
    EXTRAER_DATOS,
    ACTUALIZAR_DISPLAY
} EstadosRFID;


typedef enum { EDIT_NONE, EDIT_YEAR, EDIT_MONTH, EDIT_DOM, EDIT_HOUR, EDIT_MIN } t_EditParam;

/* --- VARIABLES GLOBALES --- */

const uint8_t TAG_REF[2][3] = {
    {112, 62, 72},  // TAG 1: Rosa
    {53, 122, 61}     // TAG 2: Verde clarito
};

volatile uint8_t lcd_ocupado = 0; 
volatile uint8_t update_audio_ui = 0; // flag para actualizar interfaz solo cuando cambie el estado

t_EstadoSistema estadoActual = ESTADO_MENU_PRINCIPAL;
t_EditParam parametroAEditar = EDIT_NONE;

volatile uint32_t ms_ticks = 0;
volatile uint8_t  flag_segundo = 0;

uint8_t update_screen = 0;
uint32_t contVerde = 0, contRosa = 0; 
uint8_t  audioHabilitado = 0;           
float    Temperatura = 22.0;            
int ultimoBrillo = -1;        
int ultimaTemp = -1;
int ultimoServo = -1;
float milivoltios = 0;
float brilloTFT = 0;
volatile uint32_t canal_0, canal_1;

uint8_t  pressedTouchPanel = 0;

int anguloServo = 90;   
int umbralTemperatura = 0;
int brilloDisplay = 50;            
char texto[40];
char texto_reloj_nuevo[40]; 

// Variables Teclado
char keypadBuffer[6]; 
uint8_t  bufferIdx = 0;

volatile uint8_t  flag_toggle_config = 0;

/* --- VARIABLES PARA GESTIÓN RFID --- */
uint8_t rfid_raw_data[5];       // Almacena los 5 bytes de datos del tag
char rfid_string_display[13] = "---"; // Cadena para mostrar en pantalla
int k_rfid = 0; // Variable auxiliar para bucles
EstadosRFID estado_rfid = ESPERA_TRAMA;

/* --- VARIABLES AUDIO ---- */

// Arrays específicos para cada color
volatile uint8_t audio_verde[N_muestras];
volatile uint8_t audio_rosa[N_muestras];

// PUNTERO MAESTRO: Indica qué array usan el ADC y DAC
volatile uint8_t *ptr_audio_activo = audio_verde;

volatile uint16_t indice_muestra;
volatile uint8_t estado_sistema = 0; // 0=IDLE, 1=REPRODUCIENDO, 2=GRABANDO
volatile uint8_t grabacion_completa = 0; // Semáforo de fin de grabación

// Variables para la lógica de color
uint16_t raw_r, raw_g, raw_b, raw_c;
uint8_t final_r, final_g, final_b;
uint8_t ultimo_tag_detectado = 0;
uint8_t flag_objeto_presente = 0; // Para evitar contar el mismo objeto 1000 veces

// Buffers para evitar parpadeos
char texto_temp_anterior[40] = "";
char texto_brillo_anterior[40] = "";
char texto_reloj_anterior[40] = ""; 

/* --- ZONAS DE PANTALLA --- */
struct t_screenZone zone_titulo     = { 20,  5, 200, 30, 0};
struct t_screenZone btn_Volver      = { 10, 280, 80, 30, 0};

struct t_screenZone btn_GoNormal    = { 40,  60, 160, 60, 0};
struct t_screenZone btn_GoConfig    = { 40, 140, 160, 60, 0};
struct t_screenZone btn_GoRTC       = { 40, 220, 160, 60, 0};

struct t_screenZone btn_EditYear    = { 20,  50, 90, 40, 0};
struct t_screenZone btn_EditMonth   = { 130, 50, 90, 40, 0};
struct t_screenZone btn_EditDay     = { 20, 100, 90, 40, 0};
struct t_screenZone btn_EditHour    = { 130, 100, 90, 40, 0};
struct t_screenZone btn_EditMin     = { 75, 150, 90, 40, 0};

struct t_screenZone zone_servo_val = { 20,  40, 200, 30, 0};
struct t_screenZone btn_servo_dec  = { 30,  75,  50, 30, 0};
struct t_screenZone btn_servo_inc  = {170,  75,  50, 30, 0};
struct t_screenZone zone_brillo_val= { 20, 110, 200, 30, 0};
struct t_screenZone btn_brillo_dec = { 30, 145,  50, 30, 0};
struct t_screenZone btn_brillo_inc = {170, 145,  50, 30, 0};

// NUEVOS BOTONES DE NAVEGACIÓN (En menú config)
struct t_screenZone btn_GoVerdeConfig = { 20, 180, 100, 40, 0};
struct t_screenZone btn_GoRosaConfig  = { 130, 180, 100, 40, 0};

struct t_screenZone keys[12];

/* --- PROTOTIPOS --- */
void init_ADC(void);
void init_ADC_microfono(void);

/* --- [CORRECCIÓN SEDA] PROTECCIÓN DE PANTALLA ATÓMICA --- */
void disable_critical_irqs(void) {
    __disable_irq();  // Apaga interrupciones a nivel CPU
    lcd_ocupado = 1;                
}

void enable_critical_irqs(void) {
    lcd_ocupado = 0;                
    __enable_irq();   // Reactiva interrupciones
}

/* --- IMPLEMENTACIÓN DE FUNCIONES GRÁFICAS AUXILIARES --- */

void escribirTextoDinamico(uint16_t x, uint16_t y, char* str, uint16_t colorTexto, uint16_t colorFondo) {
    GUI_Text(x, y, (uint8_t*)str, colorTexto, colorFondo);
}

/* --- CONFIGURACIÓN DE HARDWARE --- */
// (Omitida configGPIO original porque usamos EINT)

void SysTick_config(void) {
    SysTick->LOAD = 1000000 - 1; // 10ms
    SysTick->VAL = 0;
    SysTick->CTRL = (1 << 2) | (1 << 1) | (1 << 0);
    NVIC_SetPriority(SysTick_IRQn, 3);
}

/* --- SYSTICK MODIFICADO --- */
void SysTick_Handler(void) {
    static uint16_t contador_pulsacion = 0;
    static uint8_t  bloqueo_evento = 0;
    static uint16_t contador_1s = 0;

    ms_ticks += 10; 

    contador_1s++;
    if (contador_1s >= 100) { 
        contador_1s = 0;
        flag_segundo = 1; 
    }
    
    if ( (LPC_GPIO2->FIOPIN & (1 << 12)) == 0 ) {
        if (bloqueo_evento == 0) {
            contador_pulsacion++;
            if (contador_pulsacion >= 200) { 
                flag_toggle_config = 1;
                bloqueo_evento = 1;
            }
        }
    } 
    else {
        contador_pulsacion = 0;
        bloqueo_evento = 0;
    }
}

/* --- FUNCIONES RTC --- */

void set_time_default(void) {
    LPC_RTC->YEAR  = 2025; LPC_RTC->MONTH = 12; LPC_RTC->DOM = 22;
    LPC_RTC->HOUR  = 10;   LPC_RTC->MIN   = 0;  LPC_RTC->SEC = 0;
}

void init_RTC(void) {
    LPC_SC->PCONP |= (1<<9);
    LPC_RTC->CCR  = 0x00;
    LPC_RTC->CIIR = 0x00;
    LPC_RTC->AMR  = 0xFF;
    LPC_RTC->ILR  = 0x03;
    set_time_default();
    LPC_RTC->CCR = (1<<4);
    LPC_RTC->CIIR = (1<<0);
    NVIC_EnableIRQ(RTC_IRQn);
    LPC_RTC->CCR |= (1<<0);
}

void RTC_IRQHandler(void) {
    LPC_RTC->ILR |= 0x01;
}

void actualizarRelojPantalla(uint16_t x, uint16_t y, uint16_t colorTexto) {
    sprintf(texto_reloj_nuevo, "%02d/%02d/%d  %02d:%02d:%02d   ", 
            LPC_RTC->DOM & 0x3F, LPC_RTC->MONTH & 0x0F, LPC_RTC->YEAR & 0x0FFF, 
            LPC_RTC->HOUR & 0x1F, LPC_RTC->MIN & 0x3F, LPC_RTC->SEC & 0x3F);
    
    if (strcmp(texto_reloj_nuevo, texto_reloj_anterior) != 0) {
        disable_critical_irqs(); // Bloqueo Hardware
        escribirTextoDinamico(x, y, texto_reloj_nuevo, colorTexto, White);
        enable_critical_irqs();  // Desbloqueo Hardware
        strcpy(texto_reloj_anterior, texto_reloj_nuevo);
    }
}

void actualizarParametroRTC(void) {
    int valor = atoi(keypadBuffer);
    LPC_RTC->CCR &= ~(1 << CLKEN);
    if (parametroAEditar == EDIT_YEAR)   { if(valor >= 2000 && valor <= 2099) LPC_RTC->YEAR = valor; }
    else if (parametroAEditar == EDIT_MONTH) { if(valor >= 1 && valor <= 12) LPC_RTC->MONTH = valor; }
    else if (parametroAEditar == EDIT_DOM)   { if(valor >= 1 && valor <= 31)    LPC_RTC->DOM = valor; }
    else if (parametroAEditar == EDIT_HOUR)  { if(valor >= 0 && valor <= 23)    LPC_RTC->HOUR = valor; }
    else if (parametroAEditar == EDIT_MIN)   { if(valor >= 0 && valor <= 59)    LPC_RTC->MIN = valor; }
    LPC_RTC->CCR |= (1 << CLKEN);
}

/* --- FUNCIONES GRÁFICAS --- */

void squareButton(struct t_screenZone* zone, char * text, uint16_t textColor, uint16_t lineColor) {
    LCD_DrawLine(zone->x - 5, zone->y, zone->x + zone->size_x + 5, zone->y, lineColor);
    LCD_DrawLine(zone->x - 5, zone->y, zone->x - 5, zone->y + zone->size_y, lineColor);
    LCD_DrawLine(zone->x - 5, zone->y + zone->size_y, zone->x + zone->size_x + 5, zone->y + zone->size_y, lineColor);
    LCD_DrawLine(zone->x + zone->size_x + 5, zone->y, zone->x + zone->size_x + 5, zone->y + zone->size_y, lineColor);
    GUI_Text(zone->x + zone->size_x/2 - (strlen(text)/2)*8, zone->y + zone->size_y/2 - 8, (uint8_t*) text, textColor, White);
}

void drawMinus(struct t_screenZone* zone, uint16_t lineColor) {
    LCD_DrawLine(zone->x + 5, zone->y + zone->size_y/2, zone->x + zone->size_x - 5, zone->y + zone->size_y/2, lineColor);
}

void drawAdd(struct t_screenZone* zone, uint16_t lineColor) {
    drawMinus(zone, lineColor);
    LCD_DrawLine(zone->x + zone->size_x/2, zone->y + 5, zone->x + zone->size_x/2, zone->y + zone->size_y - 5, lineColor);
}

int8_t zoneNewPressed(struct t_screenZone* zone) {
    if (pressedTouchPanel == 1 && zone->pressed == 0) {
        if ((display.x > zone->x) && (display.x < zone->x + zone->size_x) && 
            (display.y > zone->y) && (display.y < zone->y + zone->size_y)) {
            zone->pressed = 1; return 1;
        }
    }
    return 0;
}

/* --- DIBUJO DE PANTALLAS --- */

void mostrarMenuPrincipal(void) {
    disable_critical_irqs(); 
    LCD_Clear(White); 
    enable_critical_irqs();
    
    disable_critical_irqs(); squareButton(&zone_titulo, "MENU PRINCIPAL", Black, Red); enable_critical_irqs();
    disable_critical_irqs(); squareButton(&btn_GoNormal, "MODO NORMAL", Black, Red); enable_critical_irqs();
    disable_critical_irqs(); squareButton(&btn_GoConfig, "MODO CONFIGURACION", Black, Red); enable_critical_irqs();
    disable_critical_irqs(); squareButton(&btn_GoRTC, "AJUSTE FECHA/HORA", Black, Red); enable_critical_irqs();
    
    sprintf(texto_reloj_nuevo, "%02d/%02d/%d  %02d:%02d:%02d   ", 
            LPC_RTC->DOM & 0x3F, LPC_RTC->MONTH & 0x0F, LPC_RTC->YEAR & 0x0FFF, 
            LPC_RTC->HOUR & 0x1F, LPC_RTC->MIN & 0x3F, LPC_RTC->SEC & 0x3F);
    
    disable_critical_irqs(); escribirTextoDinamico(20, 40, texto_reloj_nuevo, Black, White); enable_critical_irqs();
    strcpy(texto_reloj_anterior, texto_reloj_nuevo);
    texto_temp_anterior[0] = '\0';
    texto_brillo_anterior[0] = '\0';
}

void mostrarModoNormal(void) {
    disable_critical_irqs(); LCD_Clear(White); squareButton(&zone_titulo, "MODO NORMAL", Black, Blue); enable_critical_irqs();
    
    texto_reloj_anterior[0] = '\0'; 
    sprintf(texto_reloj_nuevo, "%02d/%02d/%d  %02d:%02d:%02d   ", 
            LPC_RTC->DOM & 0x3F, LPC_RTC->MONTH & 0x0F, LPC_RTC->YEAR & 0x0FFF, 
            LPC_RTC->HOUR & 0x1F, LPC_RTC->MIN & 0x3F, LPC_RTC->SEC & 0x3F);
    
    disable_critical_irqs();
    escribirTextoDinamico(45, 40, texto_reloj_nuevo, Black, White);
    LCD_DrawLine(10, 65, 230, 65, Blue);
    GUI_Text(20, 75, (uint8_t*)"DATOS SISTEMA:", Blue, White);
    enable_critical_irqs();
    
    texto_temp_anterior[0] = '\0'; 
    
    sprintf(texto, "RFID: %s       ", rfid_string_display);
    disable_critical_irqs(); GUI_Text(30, 115, (uint8_t*)texto, Black, White);
    LCD_DrawLine(10, 145, 230, 145, Blue);
    GUI_Text(20, 155, (uint8_t*)"OBJETOS PROCESADOS:", Blue, White); enable_critical_irqs();
//		sprintf(texto, "ADC RAW: %4d   ", canal_0); 
//		GUI_Text(20, 155, (uint8_t*)texto, Red, White); 
// -------------------------------

LCD_DrawLine(10, 145, 230, 145, Blue);
    
    sprintf(texto, "VERDES: %d  ", contVerde);
    disable_critical_irqs(); GUI_Text(40, 175, (uint8_t*)texto, Green, White); enable_critical_irqs();
    
    sprintf(texto, "ROSAS: %d  ", contRosa);
    disable_critical_irqs(); GUI_Text(40, 195, (uint8_t*)texto, Magenta, White); enable_critical_irqs();

    disable_critical_irqs();
    LCD_DrawLine(10, 225, 230, 225, Blue);
    GUI_Text(20, 235, (uint8_t*)"SISTEMA DE AUDIO:", Blue, White);
    if (audioHabilitado) { GUI_Text(160, 235, (uint8_t*)"[ ON ] ", Green, White); } else { GUI_Text(160, 235, (uint8_t*)"[ OFF ]", Red, White); }
    squareButton(&btn_Volver, "VOLVER", Black, Red);
    enable_critical_irqs();
}

void mostrarSeleccionRTC(void) {
    disable_critical_irqs(); LCD_Clear(White); squareButton(&zone_titulo, "AJUSTE DE HORA", Black, Blue); enable_critical_irqs();
    
    sprintf(texto, "ANYO:%d", LPC_RTC->YEAR & 0x0FFF); 
    disable_critical_irqs(); squareButton(&btn_EditYear, texto, Black, Blue); enable_critical_irqs();
    sprintf(texto, "MES:%02d", (LPC_RTC->MONTH & 0x0F)); 
    disable_critical_irqs(); squareButton(&btn_EditMonth, texto, Black, Blue); enable_critical_irqs();
    sprintf(texto, "DIA:%02d", LPC_RTC->DOM & 0x3F); 
    disable_critical_irqs(); squareButton(&btn_EditDay, texto, Black, Blue); enable_critical_irqs();
    sprintf(texto, "HORA:%02d", LPC_RTC->HOUR & 0x1F); 
    disable_critical_irqs(); squareButton(&btn_EditHour, texto, Black, Blue); enable_critical_irqs();
    sprintf(texto, "MIN:%02d", LPC_RTC->MIN & 0x3F); 
    disable_critical_irqs(); squareButton(&btn_EditMin, texto, Black, Blue); enable_critical_irqs();
    disable_critical_irqs(); squareButton(&btn_Volver, "VOLVER", Red, Red); enable_critical_irqs();
}

void dibujarTeclado(void) {
    int k; char label[4];
    disable_critical_irqs(); LCD_Clear(White); GUI_Text(60, 15, (uint8_t*)"INTRODUZCA VALOR:", Black, White); GUI_Text(110, 45, (uint8_t*)keypadBuffer, Red, White); enable_critical_irqs();
    
    for (k = 0; k < 12; k++) {
        keys[k].x = 45 + (k % 3) * 60; keys[k].y = 80 + (k / 3) * 45;
        keys[k].size_x = 50; keys[k].size_y = 35; keys[k].pressed = 0;
        if (k < 9) sprintf(label, "%d", k + 1); else if (k == 9) strcpy(label, "C"); else if (k == 10) strcpy(label, "0"); else strcpy(label, "OK");
        disable_critical_irqs(); squareButton(&keys[k], label, Black, Blue); enable_critical_irqs();
    }
}

void mostrarModoConfig(void) {
    disable_critical_irqs(); LCD_Clear(White); squareButton(&zone_titulo, "CONFIG GENERAL", Black, Blue); enable_critical_irqs();
    
    // PWM
    sprintf(texto, "Servo: %3d      ", anguloServo); 
    disable_critical_irqs(); escribirTextoDinamico(zone_servo_val.x + 10, zone_servo_val.y + 7, texto, Black, White); enable_critical_irqs();
    sprintf(texto, "Brillo: %3d%%     ", brilloDisplay); 
    disable_critical_irqs(); escribirTextoDinamico(zone_brillo_val.x + 10, zone_brillo_val.y + 7, texto, Black, White); enable_critical_irqs();
    strcpy(texto_brillo_anterior, texto); 
    disable_critical_irqs(); drawMinus(&btn_servo_dec, Black); drawAdd(&btn_servo_inc, Black); drawMinus(&btn_brillo_dec, Black); drawAdd(&btn_brillo_inc, Black); enable_critical_irqs();

    // NUEVOS BOTONES DE NAVEGACIÓN PARA AUDIO
    disable_critical_irqs();
    LCD_DrawLine(10, 175, 230, 175, Blue); // Separador
    squareButton(&btn_GoVerdeConfig, "CONF VERDE", Black, Green);
    squareButton(&btn_GoRosaConfig,  "CONF ROSA",  Black, Magenta);
    squareButton(&btn_Volver, "VOLVER", Red, Red);
    enable_critical_irqs();
}

// Nueva función genérica para mostrar el submenú de color
void mostrarSubMenuColor(char* titulo, uint16_t color) {
    disable_critical_irqs();
    LCD_Clear(White);
    squareButton(&zone_titulo, titulo, Black, color);
    
    // Instrucciones para los botones físicos
    GUI_Text(20, 60, (uint8_t*)"USE BOTONES:", Black, White);
    GUI_Text(20, 90, (uint8_t*)"KEY2: GRABAR", Red, White);
    GUI_Text(20, 120, (uint8_t*)"KEY1: REPRODUCIR", Blue, White);
    
    squareButton(&btn_Volver, "VOLVER", Black, Red);
    enable_critical_irqs();
}

/* --- PERIFÉRICOS --- */

void configPWM(void) {
    LPC_SC->PCONP |= (1<<6);        
    LPC_PINCON->PINSEL3 |= (2<<20); 
    LPC_PWM1->MR0 = Fpclk_pwm * Tpwm - 1; 
    LPC_PWM1->MR6 = (LPC_PWM1->MR0 * brilloDisplay) / 100; 
    LPC_PWM1->LER |= (1<<0) | (1<<6);
    LPC_PWM1->PCR |= (1<<14);           
    LPC_PWM1->TCR |= (1<<0) | (1<<3);               
}

void checkTouchPanel(void) {
    int i;
    Coordinate* coord = Read_Ads7846();
    if (coord != NULL) {
        getDisplayPoint(&display, coord, &matrix); 
        pressedTouchPanel = 1;
    } else {
        pressedTouchPanel = 0;
        // ¡IMPORTANTE! RESETEAR TODOS LOS BOTONES AL LEVANTAR EL DEDO
        btn_GoNormal.pressed = 0; btn_GoConfig.pressed = 0; btn_GoRTC.pressed = 0; btn_Volver.pressed = 0;
        btn_EditYear.pressed = 0; btn_EditMonth.pressed = 0; btn_EditDay.pressed = 0; 
        btn_EditHour.pressed = 0; btn_EditMin.pressed = 0;
        btn_servo_dec.pressed = 0; btn_servo_inc.pressed = 0;
        btn_brillo_dec.pressed = 0; btn_brillo_inc.pressed = 0;
        // Resetear botones nuevos
        btn_GoVerdeConfig.pressed = 0; btn_GoRosaConfig.pressed = 0;
        for(i=0; i<12; i++) keys[i].pressed = 0;
    }
}

uint8_t leer_KEY1(void) {
    static uint8_t ultimo_estado = 1;
    int d;
    uint8_t estado_actual = (LPC_GPIO2->FIOPIN >> 11) & 0x01;
    if (ultimo_estado == 1 && estado_actual == 0) {
        for(d=0; d<10000; d++);
        ultimo_estado = estado_actual;
        return 1;
    }
    ultimo_estado = estado_actual;
    return 0;
}

void check_sensores(void){
    int tempEntera;
    char texto_nuevo[40];
    
    // Lectura de Sensores
    int lectura_potenciometro = (canal_0 * 100) / 4095; 
    milivoltios = (canal_1 * 3300.0) / 4095.0;
    Temperatura = milivoltios / 10.0;
    tempEntera = (int)Temperatura;

    // Gestión Brillo
    if (estadoActual != ESTADO_MODO_CONFIG) {
        if (abs(lectura_potenciometro - brilloDisplay) > 1) {
            brilloDisplay = lectura_potenciometro;
        }
    }

    if ( brilloDisplay != ultimoBrillo ) { 
        if (brilloDisplay > 100) brilloDisplay = 100;
        if (brilloDisplay < 0) brilloDisplay = 0;
        brilloTFT = brilloDisplay;
        LPC_PWM1->MR6 = (LPC_PWM1->MR0 * brilloTFT) / 100;
        LPC_PWM1->LER |= (1<<6); 
        ultimoBrillo = brilloDisplay;
        
        if (estadoActual == ESTADO_MODO_CONFIG) {
            sprintf(texto_nuevo, "Brillo: %3d%%      ", brilloDisplay);
            if (strcmp(texto_nuevo, texto_brillo_anterior) != 0) {
                disable_critical_irqs();
                escribirTextoDinamico(zone_brillo_val.x + 10, zone_brillo_val.y + 7, texto_nuevo, Black, White);
                enable_critical_irqs();
                strcpy(texto_brillo_anterior, texto_nuevo);
            }
        }
    }

    sprintf(texto_nuevo, "Temperatura: %5.1f C      ", Temperatura);
    if (estadoActual == ESTADO_MODO_NORMAL) {
        if (strcmp(texto_nuevo, texto_temp_anterior) != 0) {
            disable_critical_irqs();
            escribirTextoDinamico(30, 95, texto_nuevo, Black, White);
            enable_critical_irqs();
            strcpy(texto_temp_anterior, texto_nuevo);
        }
    }
}

/* -------- HARDWARE AUDIO ---------*/

void init_DAC(void) {
    LPC_PINCON->PINSEL1 &= ~(3 << 20); // Limpiar
    LPC_PINCON->PINSEL1 |= (2 << 20);  // AOUT
    LPC_PINCON->PINMODE1 |= (2 << 20); 
    LPC_DAC->DACCTRL = 0;
}

void init_ADC_microfono(void) {
    LPC_SC->PCONP |= (1 << 12); 
    LPC_PINCON->PINSEL1 &= ~(3 << 18); LPC_PINCON->PINSEL1 |= (1 << 18); 
    LPC_PINCON->PINMODE1 &= ~(3 << 18); LPC_PINCON->PINMODE1 |= (2 << 18); 
    LPC_ADC->ADCR = (1 << 2) | (1 << 8) | (1 << 21) | (7 << 24); 
    LPC_ADC->ADINTEN = (1 << 2); 
    NVIC_EnableIRQ(ADC_IRQn); NVIC_SetPriority(ADC_IRQn, 0); 
}

void init_ADC(void) {   
    LPC_SC->PCONP |= (1<<12); 
    LPC_PINCON->PINSEL1 |= ((1<<14)|(1<<16));
    LPC_PINCON->PINMODE1 |= ((2<<14)|(2<<16)); 
    LPC_ADC->ADCR = (1<<8) | (1<<21); 
    LPC_ADC->ADINTEN = (1<<0) | (1<<1);
    NVIC_EnableIRQ(ADC_IRQn); NVIC_SetPriority(ADC_IRQn, 6);       
}

void TIMER2_IRQHandler(void) {   
    LPC_TIM2->IR |= (1 << 0); 
    if (estado_sistema == 2) return; 
    LPC_ADC->ADCR = (LPC_ADC->ADCR & 0xFFFFFF00) | (1 << 0) | (1 << 24); 
}

void ADC_IRQHandler(void) {    
    uint32_t stat = LPC_ADC->ADSTAT;
    
    // --- AUDIO (Canal 2) ---
    if (stat & (1 << 2)) {
        uint8_t valor_audio = (LPC_ADC->ADDR2 >> 8) & 0xFF; 
        
        // ¡USAMOS EL PUNTERO GLOBAL! (Graba en Verde o Rosa según toque)
        ptr_audio_activo[indice_muestra++] = valor_audio;

        if (indice_muestra >= N_muestras) {
            LPC_TIM1->TCR = 0x02; 
            estado_sistema = 0;      
            grabacion_completa = 1;  
            indice_muestra = 0;      
            
            init_ADC();       
            LPC_TIM2->TCR = 0x01;    
        }
    }
    // --- SENSORES ---
    else if (stat & (1 << 0)) {
        canal_0 = (LPC_ADC->ADDR0 >> 4) & 0xFFF; 
        if (estado_sistema != 2) LPC_ADC->ADCR = (LPC_ADC->ADCR & 0xFFFFFF00) | (1 << 1) | (1 << 24);
    }
    else if (stat & (1 << 1)) {
        canal_1 = (LPC_ADC->ADDR1 >> 4) & 0xFFF; 
    }
}

void init_TIMER2(void) {
    LPC_SC->PCONP |= (1 << 22); LPC_TIM2->MR0 = (F_pclk / F_muestreo) - 1; 
    LPC_TIM2->MCR = (1 << 0) | (1 << 1); LPC_TIM2->TCR = 0x01; 
    NVIC_EnableIRQ(TIMER2_IRQn); NVIC_SetPriority(TIMER2_IRQn, 5); 
}

/* ---------- LOGICA AUDIO ------------*/

void iniciar_grabacion_color(volatile uint8_t *buffer_destino) {
    LPC_TIM2->TCR = 0x00; // Apagar Timer Sensores
    ptr_audio_activo = buffer_destino; // Apuntar al buffer correcto
    estado_sistema = 2; 
    indice_muestra = 0;
    init_ADC_microfono();
    LPC_TIM1->TCR = 0x02; LPC_TIM1->TCR = 0x01; 
}

void iniciar_reproduccion_color(volatile uint8_t *buffer_origen) {
    ptr_audio_activo = buffer_origen; // Apuntar al buffer correcto
    estado_sistema = 1; 
    indice_muestra = 0;
    LPC_TIM3->TCR = 0x02; LPC_TIM3->TCR = 0x01;
}

void TIMER3_IRQHandler(void)
{
    LPC_TIM3->IR |= (1<<0); 
    // Usamos el puntero global para reproducir
    LPC_DAC->DACR = ptr_audio_activo[indice_muestra++] << 8; 
    
    if(indice_muestra >= N_muestras){
        indice_muestra = 0;
        LPC_TIM3->TCR = 0x02; 
        LPC_DAC->DACR = 0;    
        estado_sistema = 0;   
    }
}   

void init_TIMER1(void) {
    LPC_SC->PCONP |= (1<<2); 
    LPC_PINCON->PINSEL3 &= ~(3 << 18); LPC_PINCON->PINSEL3 |= (3 << 18); 
    LPC_TIM1->MR1 = (F_pclk / (F_sample * 2)) - 1; 
    LPC_TIM1->MCR = (1 << 4); 
    LPC_TIM1->EMR |= (3 << 6); 
    LPC_TIM1->TCR = 0x02;
}

void init_TIMER3(void) {
    LPC_SC->PCONP |= (1<<23); LPC_TIM3->MR0 = (F_pclk / F_sample ) - 1; 
    LPC_TIM3->MCR = 0x03; LPC_TIM3->TCR = 0x02; 
    NVIC_EnableIRQ(TIMER3_IRQn); NVIC_SetPriority(TIMER3_IRQn, 0);
}

void init_Externas() {
    LPC_PINCON->PINSEL4 |= (1<<22); LPC_SC->EXTMODE |= (1<<1); NVIC_EnableIRQ(EINT1_IRQn);
    LPC_PINCON->PINSEL4 |= (1<<24); LPC_SC->EXTMODE |= (1<<2); LPC_SC->EXTPOLAR &= ~(1<<2); NVIC_EnableIRQ(EINT2_IRQn);
}

void EINT1_IRQHandler(void) {
    // 1. Limpiar flag de interrupción inmediatamente
    LPC_SC->EXTINT |= (1 << 1); 

    // 2. Debouncing básico por software (Opcional si tienes mucho rebote)
    // Se puede usar un timer, pero para simplificar aquí, asumiremos que el hardware ayuda.
    
    // 3. Lógica según el Estado del Sistema
    switch(estadoActual) {
        case ESTADO_MODO_NORMAL:
            // En modo normal: KEY1 activa/desactiva el permiso de audio
            audioHabilitado = !audioHabilitado;
            update_audio_ui = 1; // Avisamos al main para que pinte el icono
            break;

        case ESTADO_CONFIG_VERDE:
        case ESTADO_CONFIG_ROSA:
            // En menús de configuración: KEY1 reproduce la grabación actual
            // Solo si el sistema de audio está libre (IDLE)
            if (estado_sistema == 0) {
                iniciar_reproduccion_color(ptr_audio_activo);
            }
            break;

        default:
            // En otros menús (Principal, RTC...) KEY1 no hace nada
            break;
    }
}

void EINT2_IRQHandler(void) { // GRABAR (KEY2)
    LPC_SC->EXTINT |= (1 << 2);
    // Graba en el color que esté seleccionado actualmente
    if (estado_sistema == 0) iniciar_grabacion_color(ptr_audio_activo);
}


/* --- FUNCIONES DE COLOR --- */

uint8_t saturar_valor(uint32_t valor) {
    if (valor > 255) return 255;
    return (uint8_t)valor;
}

uint8_t identificarTag(uint8_t r, uint8_t g, uint8_t b) {
    int i;
    int32_t diff;
    int32_t min_diff = 10000; 
    uint8_t id_detectado = 0;

    // Filtro de oscuridad (si hay poca luz, ignorar)
    if (r < 20 && g < 20 && b < 20) return 0;

    for(i = 0; i < 2; i++) {
        // Distancia Manhattan
        int dr = abs((int)r - (int)TAG_REF[i][0]);
        int dg = abs((int)g - (int)TAG_REF[i][1]);
        int db = abs((int)b - (int)TAG_REF[i][2]);
        
        diff = dr + dg + db;

        if (diff < min_diff) {
            min_diff = diff;
            if (diff < UMBRAL_DETECCION) {
                id_detectado = i + 1; // 1:Rosa, 2:Verde
            }
        }
    }
    return id_detectado;
}

void procesar_sensor_color(void) {
    uint32_t temp_r, temp_g, temp_b; uint8_t tag_actual;
    TCS34725_getRawData(&raw_r, &raw_g, &raw_b, &raw_c);
    
    if (raw_c > 0) {
        temp_r = (raw_r * 255) / raw_c; temp_g = (raw_g * 255) / raw_c; temp_b = (raw_b * 255) / raw_c;
        final_r = saturar_valor(temp_r); final_g = saturar_valor(temp_g); final_b = saturar_valor(temp_b);
    } else { final_r = 0; final_g = 0; final_b = 0; }

    tag_actual = identificarTag(final_r, final_g, final_b);
    
    if (estadoActual == ESTADO_MODO_NORMAL) {
        char txt_debug[40]; sprintf(txt_debug, "R:%03d G:%03d B:%03d   ", final_r, final_g, final_b);
        disable_critical_irqs(); GUI_Text(10, 260, (uint8_t*)txt_debug, Black, White); enable_critical_irqs();
    }
		
    // --- MÁQUINA DE ESTADOS DE DETECCIÓN Y REPRODUCCIÓN ---
    if (tag_actual != 0 && flag_objeto_presente == 0) {
        flag_objeto_presente = 1; 
        ultimo_tag_detectado = tag_actual;

        if (tag_actual == 1) { // ROSA
            contRosa++;
            // Reproducir Audio Rosa AUTOMÁTICAMENTE si está habilitado
            if (audioHabilitado && estado_sistema == 0) {
                iniciar_reproduccion_color(audio_rosa);
            }
        } 
        else if (tag_actual == 2) { // VERDE
            contVerde++;
            // Reproducir Audio Verde AUTOMÁTICAMENTE si está habilitado
            if (audioHabilitado && estado_sistema == 0) {
                iniciar_reproduccion_color(audio_verde);
            }
        }
        
        if (estadoActual == ESTADO_MODO_NORMAL) mostrarModoNormal();
    } 
    else if (tag_actual == 0) {
        flag_objeto_presente = 0;
    }
}

/* --- INICIALIZACIÓN DE SENSORES IR --- */
void init_IR_Sensores(void) {
    // 1. Configurar PINSEL para que sean GPIO (00)
    
    LPC_PINCON->PINSEL2 &= ~((3UL << 28) | (3UL << 30)); // P1.14 y P1.15 como GPIO

    // 2. Configurar la Dirección como ENTRADA (Input = 0)
    LPC_GPIO1->FIODIR &= ~(PIN_IR_VERDE | PIN_IR_ROSA);

    // 3. Configurar Resistencias Internas
    LPC_PINCON->PINMODE2 &= ~((3UL << 28) | (3UL << 30)); 
}

/* --- FUNCIÓN PARA LEER ESTADO DE LOS SENSORES --- */
// Retorna 1 si detecta objeto (reflexión), 0 si no.
// NOTA: Depende del módulo, a veces D0 es LOW al detectar. 
// Tendrás que ajustar el "!" según tus pruebas.
uint8_t leerSensorVerde(void) {
    // Si el módulo pone D0 a LOW (0) al detectar objeto:
    if ( (LPC_GPIO1->FIOPIN & PIN_IR_VERDE) == 0 ) return 1; 
    return 0;
}

uint8_t leerSensorRosa(void) {
    if ( (LPC_GPIO1->FIOPIN & PIN_IR_ROSA) == 0 ) return 1;
    return 0;
}

/* --- MAIN LOOP --- */
int main(void) {
    int j;
    uint32_t last_sensor_check = 0;
    uint32_t last_touch_check = 0;

    LCD_Initializtion(); LCD_Clear(White); TP_Init();
    NVIC_SetPriorityGrouping(2);
    
    // Inicialización periféricos
    init_RTC();
    configPWM();
    init_Externas();
		init_IR_Sensores();	
    init_ADC();      
    init_DAC();     
		TCS34725_init();
		TCS34725_enable();
    init_TIMER1(); 
    init_TIMER2(); 
    init_TIMER3(); 
    SysTick_config();
    
    uart3_init(9600); ptr_rx = buffer;
        
    mostrarMenuPrincipal();
        
    while(1) {
        
        // --- PROTECCIÓN CRÍTICA DE AUDIO ---
        // Si estamos grabando o reproduciendo, no hacemos nada más.
        if (estado_sistema != 0) continue;

        /* --- MÁQUINA DE ESTADOS RFID --- */
        switch(estado_rfid) {
            case ESPERA_TRAMA: if(rx_completa == 1) { rx_completa = 0; estado_rfid = VALIDAR_CABECERA; } break;
            case VALIDAR_CABECERA: if(buffer[0] == 0x02) estado_rfid = EXTRAER_DATOS; else { ptr_rx = buffer; estado_rfid = ESPERA_TRAMA; } break;
            case EXTRAER_DATOS: if(buffer[9] == 0x00) { for(k_rfid=0; k_rfid<5; k_rfid++) rfid_raw_data[k_rfid] = buffer[3+k_rfid]; estado_rfid = ACTUALIZAR_DISPLAY; } else { ptr_rx = buffer; estado_rfid = ESPERA_TRAMA; } break;
            case ACTUALIZAR_DISPLAY: 
                sprintf(rfid_string_display, "%02X%02X%02X%02X%02X", rfid_raw_data[0], rfid_raw_data[1], rfid_raw_data[2], rfid_raw_data[3], rfid_raw_data[4]);
                if (estadoActual == ESTADO_MODO_NORMAL) { disable_critical_irqs(); sprintf(texto, "RFID: %s       ", rfid_string_display); escribirTextoDinamico(30, 115, texto, Black, White); enable_critical_irqs(); }
                ptr_rx = buffer; estado_rfid = ESPERA_TRAMA; break;
        }

        // 1. GESTIÓN SENSORES
        if ( (ms_ticks - last_sensor_check) >= T_REFRESCO_SENSORES_MS ) {
            last_sensor_check = ms_ticks;
            check_sensores();        
            procesar_sensor_color();
        }
				
				// 1.1 GESTIÓN UI AUDIO (Flag levantado por ISR)
        if (update_audio_ui && estadoActual == ESTADO_MODO_NORMAL) {
            disable_critical_irqs();
            if (audioHabilitado) { GUI_Text(160, 235, (uint8_t*)"[ ON ] ", Green, White); } 
            else { GUI_Text(160, 235, (uint8_t*)"[ OFF ]", Red, White); }
            enable_critical_irqs();
            update_audio_ui = 0; 
        }
        
        // 2. GESTIÓN TÁCTIL
        if ( (ms_ticks - last_touch_check) >= T_REFRESCO_TOUCH_MS ) { checkTouchPanel(); last_touch_check = ms_ticks; }

        // 3. CAMBIO DE MODO
        if (flag_toggle_config) {
            flag_toggle_config = 0; 
            if (estadoActual == ESTADO_MODO_CONFIG || estadoActual == ESTADO_CONFIG_VERDE || estadoActual == ESTADO_CONFIG_ROSA) {
                estadoActual = ESTADO_MENU_PRINCIPAL; mostrarMenuPrincipal();
            } else {
                estadoActual = ESTADO_MODO_CONFIG; mostrarModoConfig(); update_screen = 1; 
            }
        }

        // 4. RELOJ
        if (flag_segundo) {
            flag_segundo = 0; 
            if (estadoActual == ESTADO_MENU_PRINCIPAL) actualizarRelojPantalla(20, 40, Black);
            else if (estadoActual == ESTADO_MODO_NORMAL) actualizarRelojPantalla(45, 40, Black);
        }

        // 5. MÁQUINA DE ESTADOS TÁCTIL (NAVEGACIÓN)
        if (pressedTouchPanel) {
            switch(estadoActual) {
                case ESTADO_MENU_PRINCIPAL:
                    if (zoneNewPressed(&btn_GoNormal)) { estadoActual = ESTADO_MODO_NORMAL; mostrarModoNormal(); }
                    else if (zoneNewPressed(&btn_GoConfig)) { estadoActual = ESTADO_MODO_CONFIG; mostrarModoConfig(); }
                    else if (zoneNewPressed(&btn_GoRTC)) { estadoActual = ESTADO_AJUSTE_RTC; mostrarSeleccionRTC(); }
                    break;

                case ESTADO_MODO_NORMAL:
                    if (zoneNewPressed(&btn_Volver)) { estadoActual = ESTADO_MENU_PRINCIPAL; mostrarMenuPrincipal(); }
                    break;

                case ESTADO_AJUSTE_RTC:
                    if (zoneNewPressed(&btn_Volver)) { estadoActual = ESTADO_MENU_PRINCIPAL; mostrarMenuPrincipal(); }
                    else if (zoneNewPressed(&btn_EditYear))  { parametroAEditar = EDIT_YEAR;  estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditMonth)) { parametroAEditar = EDIT_MONTH; estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditDay))   { parametroAEditar = EDIT_DOM;   estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditHour))  { parametroAEditar = EDIT_HOUR;  estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditMin))   { parametroAEditar = EDIT_MIN;   estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    break;

                case ESTADO_TECLADO:
                    for (j = 0; j < 12; j++) {
                        if (zoneNewPressed(&keys[j])) {
                            if (j < 9 || j == 10) { 
                                if (bufferIdx < 4) { keypadBuffer[bufferIdx] = (j == 10) ? '0' : (j + 1 + '0'); bufferIdx++; keypadBuffer[bufferIdx] = '\0'; dibujarTeclado(); }
                            } else if (j == 9) { estadoActual = ESTADO_AJUSTE_RTC; mostrarSeleccionRTC(); } 
                              else if (j == 11) { actualizarParametroRTC(); estadoActual = ESTADO_AJUSTE_RTC; mostrarSeleccionRTC(); }
                        }
                    }
                    break;

                // --- MODIFICACIÓN: MENÚ DE CONFIGURACIÓN ---
                case ESTADO_MODO_CONFIG:
                    if (zoneNewPressed(&btn_Volver)) { estadoActual = ESTADO_MENU_PRINCIPAL; mostrarMenuPrincipal(); }
                    else if (zoneNewPressed(&btn_servo_dec)) { if(anguloServo > 0) anguloServo-=5; update_screen=1; }
                    else if (zoneNewPressed(&btn_servo_inc)) { if(anguloServo < 180) anguloServo+=5; update_screen=1; }
                    else if (zoneNewPressed(&btn_brillo_dec)){ if(brilloDisplay > 0) brilloDisplay-=10; update_screen=1; }
                    else if (zoneNewPressed(&btn_brillo_inc)){ if(brilloDisplay < 100) brilloDisplay+=10; update_screen=1; }
                    
                    // NAVEGACIÓN A SUB-MENÚS (Establecemos el "contexto" del audio)
                    else if (zoneNewPressed(&btn_GoVerdeConfig)) {
                        ptr_audio_activo = audio_verde; // Contexto VERDE
                        estadoActual = ESTADO_CONFIG_VERDE;
                        mostrarSubMenuColor("CONF VERDE", Green);
                    }
                    else if (zoneNewPressed(&btn_GoRosaConfig)) {
                        ptr_audio_activo = audio_rosa;  // Contexto ROSA
                        estadoActual = ESTADO_CONFIG_ROSA;
                        mostrarSubMenuColor("CONF ROSA", Magenta);
                    }
                    
                    if(update_screen) {
                        LPC_PWM1->MR6 = (LPC_PWM1->MR0 * brilloDisplay) / 100; LPC_PWM1->LER |= (1<<6);
                        sprintf(texto, "Servo: %3d      ", anguloServo); disable_critical_irqs(); escribirTextoDinamico(zone_servo_val.x + 10, zone_servo_val.y + 7, texto, Black, White);
                        sprintf(texto, "Brillo: %3d%%     ", brilloDisplay); escribirTextoDinamico(zone_brillo_val.x + 10, zone_brillo_val.y + 7, texto, Black, White); enable_critical_irqs();
                        update_screen = 0; 
                    }
                    break;

                // --- MODIFICACIÓN: SUB-MENÚS (Solo volver) ---
                case ESTADO_CONFIG_VERDE:
                    if (zoneNewPressed(&btn_Volver)) { 
                        estadoActual = ESTADO_MODO_CONFIG; mostrarModoConfig(); 
                        // Nota: El puntero de audio se queda en Verde hasta que se cambie, pero al salir al menú config no importa.
                    }
                    break;

                case ESTADO_CONFIG_ROSA:
                    if (zoneNewPressed(&btn_Volver)) { 
                        estadoActual = ESTADO_MODO_CONFIG; mostrarModoConfig(); 
                    }
                    break;
            }
            pressedTouchPanel = 0; 
        }
    }
}
