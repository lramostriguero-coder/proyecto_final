/********************************************************************************
 * PROYECTO: Sistema de Control SEDA - Gestión de RTC y Teclado Táctil
 * DISPOSITIVO: NXP LPC1768
 * PROFESOR: LAB SEDA
 * SOLUCIÓN: Protección atómica (__disable_irq) para evitar corrupción en GLCD
 ********************************************************************************/

#include <LPC17xx.H>
#include <glcd.h>
#include <TouchPanel.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

/* --- DEFINICIONES DE TIMING --- */
#define T_REFRESCO_SENSORES_MS  200
#define T_REFRESCO_TOUCH_MS     50

/* --- DEFINICIONES DE HARDWARE Y RELOJES --- */
#define F_cpu 100e6                    
#define F_pclk F_cpu/4                 
#define F_wdclk F_pclk/4               
#define Fpclk_pwm 25e6                 
#define Tpwm  1e-3                     
#define F_muestreo 50

/* --- CONSTANTES RTC --- */
#define PCRTC 9                        
#define CLKEN 0                        
#define RTCIF 0                        
#define IMSEC 0                        
#define CCALEN 4                        

/* --- ESTRUCTURAS Y TIPOS --- */
struct t_screenZone {
    uint16_t x; uint16_t y;
    uint16_t size_x; uint16_t size_y;
    uint8_t  pressed;
};

typedef enum { 
    ESTADO_MENU_PRINCIPAL, 
    ESTADO_MODO_NORMAL, 
    ESTADO_MODO_CONFIG,
    ESTADO_AJUSTE_RTC,         
    ESTADO_TECLADO          
} t_EstadoSistema;

typedef enum { EDIT_NONE, EDIT_YEAR, EDIT_MONTH, EDIT_DOM, EDIT_HOUR, EDIT_MIN } t_EditParam;

/* --- VARIABLES GLOBALES --- */
volatile uint8_t lcd_ocupado = 0; 

t_EstadoSistema estadoActual = ESTADO_MENU_PRINCIPAL;
t_EditParam parametroAEditar = EDIT_NONE;

volatile uint32_t ms_ticks = 0;
volatile uint8_t  flag_segundo = 0;

uint8_t update_screen = 0;
uint32_t contVerde = 0, contRosa = 0; 
uint8_t  audioHabilitado = 0;          
float    Temperatura = 22.0;            
int ultimoBrillo = -1;       
int ultimaTemp = -1;
int ultimoServo = -1;
float milivoltios = 0;
float brilloTFT = 0;
uint32_t canal_0, canal_1;

uint8_t  pressedTouchPanel = 0;

int anguloServo = 90;   
int umbralTemperatura = 0;
int brilloDisplay = 50;           
char texto[40];
char texto_reloj_nuevo[40]; 

// Variables Teclado
char keypadBuffer[6]; 
uint8_t  bufferIdx = 0;

volatile uint8_t  flag_toggle_config = 0;

// Buffers para evitar parpadeos
char texto_temp_anterior[40] = "";
char texto_brillo_anterior[40] = "";
char texto_reloj_anterior[40] = ""; 

/* --- ZONAS DE PANTALLA --- */
struct t_screenZone zone_titulo    = { 20,  5, 200, 30, 0};
struct t_screenZone btn_Volver     = { 10, 280, 80, 30, 0};

struct t_screenZone btn_GoNormal   = { 40,  60, 160, 60, 0};
struct t_screenZone btn_GoConfig   = { 40, 140, 160, 60, 0};
struct t_screenZone btn_GoRTC      = { 40, 220, 160, 60, 0};

struct t_screenZone btn_EditYear   = { 20,  50, 90, 40, 0};
struct t_screenZone btn_EditMonth  = { 130, 50, 90, 40, 0};
struct t_screenZone btn_EditDay    = { 20, 100, 90, 40, 0};
struct t_screenZone btn_EditHour   = { 130, 100, 90, 40, 0};
struct t_screenZone btn_EditMin    = { 75, 150, 90, 40, 0};

struct t_screenZone zone_servo_val = { 20,  40, 200, 30, 0};
struct t_screenZone btn_servo_dec  = { 30,  75,  50, 30, 0};
struct t_screenZone btn_servo_inc  = {170,  75,  50, 30, 0};
struct t_screenZone zone_brillo_val= { 20, 110, 200, 30, 0};
struct t_screenZone btn_brillo_dec = { 30, 145,  50, 30, 0};
struct t_screenZone btn_brillo_inc = {170, 145,  50, 30, 0};

struct t_screenZone keys[12];

/* --- [CORRECCIÓN SEDA] PROTECCIÓN DE PANTALLA ATÓMICA --- */
// Usamos disable_irq para apagar TODAS las interrupciones (incluido SysTick)
// mientras dibujamos. Esto evita que el barrido de la pantalla se corrompa.
void disable_critical_irqs(void) {
    __disable_irq();  // Apaga interrupciones a nivel CPU
    lcd_ocupado = 1;              
}

void enable_critical_irqs(void) {
    lcd_ocupado = 0;              
    __enable_irq();   // Reactiva interrupciones
}

/* --- IMPLEMENTACIÓN DE FUNCIONES GRÁFICAS AUXILIARES --- */

void escribirTextoDinamico(uint16_t x, uint16_t y, char* str, uint16_t colorTexto, uint16_t colorFondo) {
    GUI_Text(x, y, (uint8_t*)str, colorTexto, colorFondo);
}

/* --- CONFIGURACIÓN DE HARDWARE --- */

void configGPIO(void) {
    // Configuración opcional si usas los botones de la placa
    LPC_PINCON->PINSEL4 &= ~(3 << 22);
    LPC_GPIO2->FIODIR &= ~(1 << 11);
    
    LPC_PINCON->PINSEL4 &= ~(3 << 24); 
    LPC_GPIO2->FIODIR   &= ~(1 << 12);
    
    LPC_PINCON->PINSEL7 &= ~(3 << 18);
    LPC_GPIO3->FIODIR   |= (1 << 25);
}

void SysTick_config(void) {
    SysTick->LOAD = 1000000 - 1; // 10ms
    SysTick->VAL = 0;
    SysTick->CTRL = (1 << 2) | (1 << 1) | (1 << 0);
    NVIC_SetPriority(SysTick_IRQn, 3);
}

/* --- SYSTICK MODIFICADO --- */
void SysTick_Handler(void) {
    static uint16_t contador_pulsacion = 0;
    static uint8_t  bloqueo_evento = 0;
    static uint16_t contador_1s = 0;

    ms_ticks += 10; 

    contador_1s++;
    if (contador_1s >= 100) { 
        contador_1s = 0;
        flag_segundo = 1; 
    }

    // NOTA SEDA: Al usar __disable_irq() en las funciones de dibujo,
    // este Handler NO se ejecutará si la pantalla está ocupada.
    // Por tanto, no necesitamos comprobar 'lcd_ocupado' aquí dentro.
    
    if ( (LPC_GPIO2->FIOPIN & (1 << 12)) == 0 ) {
        if (bloqueo_evento == 0) {
            contador_pulsacion++;
            if (contador_pulsacion >= 200) { 
                flag_toggle_config = 1;
                bloqueo_evento = 1;
            }
        }
    } 
    else {
        contador_pulsacion = 0;
        bloqueo_evento = 0;
    }
}

/* --- FUNCIONES RTC --- */

void set_time_default(void) {
    LPC_RTC->YEAR  = 2025; LPC_RTC->MONTH = 12; LPC_RTC->DOM = 22;
    LPC_RTC->HOUR  = 10;   LPC_RTC->MIN   = 0;  LPC_RTC->SEC = 0;
}

void init_RTC(void) {
    LPC_SC->PCONP |= (1<<9);
    LPC_RTC->CCR  = 0x00;
    LPC_RTC->CIIR = 0x00;
    LPC_RTC->AMR  = 0xFF;
    LPC_RTC->ILR  = 0x03;
    set_time_default();
    LPC_RTC->CCR = (1<<4);
    LPC_RTC->CIIR = (1<<0);
    NVIC_EnableIRQ(RTC_IRQn);
    LPC_RTC->CCR |= (1<<0);
}

void RTC_IRQHandler(void) {
    LPC_RTC->ILR |= 0x01;
}

void actualizarRelojPantalla(uint16_t x, uint16_t y, uint16_t colorTexto) {
    sprintf(texto_reloj_nuevo, "%02d/%02d/%d  %02d:%02d:%02d   ", 
            LPC_RTC->DOM & 0x3F, LPC_RTC->MONTH & 0x0F, LPC_RTC->YEAR & 0x0FFF, 
            LPC_RTC->HOUR & 0x1F, LPC_RTC->MIN & 0x3F, LPC_RTC->SEC & 0x3F);
    
    if (strcmp(texto_reloj_nuevo, texto_reloj_anterior) != 0) {
        disable_critical_irqs(); // Bloqueo Hardware
        escribirTextoDinamico(x, y, texto_reloj_nuevo, colorTexto, White);
        enable_critical_irqs();  // Desbloqueo Hardware
        strcpy(texto_reloj_anterior, texto_reloj_nuevo);
    }
}

void actualizarParametroRTC(void) {
    int valor = atoi(keypadBuffer);
    LPC_RTC->CCR &= ~(1 << CLKEN);
    if (parametroAEditar == EDIT_YEAR)   { if(valor >= 2000 && valor <= 2099) LPC_RTC->YEAR = valor; }
    else if (parametroAEditar == EDIT_MONTH) { if(valor >= 1 && valor <= 12) LPC_RTC->MONTH = valor; }
    else if (parametroAEditar == EDIT_DOM)   { if(valor >= 1 && valor <= 31)    LPC_RTC->DOM = valor; }
    else if (parametroAEditar == EDIT_HOUR)  { if(valor >= 0 && valor <= 23)    LPC_RTC->HOUR = valor; }
    else if (parametroAEditar == EDIT_MIN)   { if(valor >= 0 && valor <= 59)    LPC_RTC->MIN = valor; }
    LPC_RTC->CCR |= (1 << CLKEN);
}

/* --- FUNCIONES GRÁFICAS --- */

void squareButton(struct t_screenZone* zone, char * text, uint16_t textColor, uint16_t lineColor) {
    LCD_DrawLine(zone->x - 5, zone->y, zone->x + zone->size_x + 5, zone->y, lineColor);
    LCD_DrawLine(zone->x - 5, zone->y, zone->x - 5, zone->y + zone->size_y, lineColor);
    LCD_DrawLine(zone->x - 5, zone->y + zone->size_y, zone->x + zone->size_x + 5, zone->y + zone->size_y, lineColor);
    LCD_DrawLine(zone->x + zone->size_x + 5, zone->y, zone->x + zone->size_x + 5, zone->y + zone->size_y, lineColor);
    GUI_Text(zone->x + zone->size_x/2 - (strlen(text)/2)*8, zone->y + zone->size_y/2 - 8, (uint8_t*) text, textColor, White);
}

void drawMinus(struct t_screenZone* zone, uint16_t lineColor) {
    LCD_DrawLine(zone->x + 5, zone->y + zone->size_y/2, zone->x + zone->size_x - 5, zone->y + zone->size_y/2, lineColor);
}

void drawAdd(struct t_screenZone* zone, uint16_t lineColor) {
    drawMinus(zone, lineColor);
    LCD_DrawLine(zone->x + zone->size_x/2, zone->y + 5, zone->x + zone->size_x/2, zone->y + zone->size_y - 5, lineColor);
}

int8_t zoneNewPressed(struct t_screenZone* zone) {
    if (pressedTouchPanel == 1 && zone->pressed == 0) {
        if ((display.x > zone->x) && (display.x < zone->x + zone->size_x) && 
            (display.y > zone->y) && (display.y < zone->y + zone->size_y)) {
            zone->pressed = 1; return 1;
        }
    }
    return 0;
}

/* --- DIBUJO DE PANTALLAS (PROTECCIÓN GRANO FINO) --- */
/* SEDA: Dividimos el dibujo en bloques pequeños protegidos
   para no dejar al sistema 'sordo' demasiado tiempo seguido */

void mostrarMenuPrincipal(void) {
    disable_critical_irqs(); 
    LCD_Clear(White); 
    enable_critical_irqs();
    
    disable_critical_irqs();
    squareButton(&zone_titulo, "MENU PRINCIPAL", Black, Red);
    enable_critical_irqs();

    disable_critical_irqs();
    squareButton(&btn_GoNormal, "MODO NORMAL", Black, Red);
    enable_critical_irqs();

    disable_critical_irqs();
    squareButton(&btn_GoConfig, "MODO CONFIGURACION", Black, Red);
    enable_critical_irqs();

    disable_critical_irqs();
    squareButton(&btn_GoRTC, "AJUSTE FECHA/HORA", Black, Red);
    enable_critical_irqs();
    
    // Preparar texto inicial sin dibujar aún
    sprintf(texto_reloj_nuevo, "%02d/%02d/%d  %02d:%02d:%02d   ", 
            LPC_RTC->DOM & 0x3F, LPC_RTC->MONTH & 0x0F, LPC_RTC->YEAR & 0x0FFF, 
            LPC_RTC->HOUR & 0x1F, LPC_RTC->MIN & 0x3F, LPC_RTC->SEC & 0x3F);
    
    disable_critical_irqs();
    escribirTextoDinamico(20, 40, texto_reloj_nuevo, Black, White);
    enable_critical_irqs();
    
    strcpy(texto_reloj_anterior, texto_reloj_nuevo);

    texto_temp_anterior[0] = '\0';
    texto_brillo_anterior[0] = '\0';
}

void mostrarModoNormal(void) {
    disable_critical_irqs();
    LCD_Clear(White);
    squareButton(&zone_titulo, "MODO NORMAL", Black, Blue);
    enable_critical_irqs();
    
    texto_reloj_anterior[0] = '\0'; 
    sprintf(texto_reloj_nuevo, "%02d/%02d/%d  %02d:%02d:%02d   ", 
            LPC_RTC->DOM & 0x3F, LPC_RTC->MONTH & 0x0F, LPC_RTC->YEAR & 0x0FFF, 
            LPC_RTC->HOUR & 0x1F, LPC_RTC->MIN & 0x3F, LPC_RTC->SEC & 0x3F);
    
    disable_critical_irqs();
    escribirTextoDinamico(45, 40, texto_reloj_nuevo, Black, White);
    LCD_DrawLine(10, 65, 230, 65, Blue);
    GUI_Text(20, 75, (uint8_t*)"DATOS SISTEMA:", Blue, White);
    enable_critical_irqs();
    
    texto_temp_anterior[0] = '\0'; 
    
    disable_critical_irqs();
    GUI_Text(30, 115, (uint8_t*)"RFID: 8A4F2C (E)", Black, White);
    LCD_DrawLine(10, 145, 230, 145, Blue);
    GUI_Text(20, 155, (uint8_t*)"OBJETOS PROCESADOS:", Blue, White);
    enable_critical_irqs();
    
    sprintf(texto, "VERDES: %d  ", contVerde);
    disable_critical_irqs();
    GUI_Text(40, 175, (uint8_t*)texto, Green, White);
    enable_critical_irqs();
    
    sprintf(texto, "ROSAS: %d  ", contRosa);
    disable_critical_irqs();
    GUI_Text(40, 195, (uint8_t*)texto, Magenta, White);
    enable_critical_irqs();

    disable_critical_irqs();
    LCD_DrawLine(10, 225, 230, 225, Blue);
    GUI_Text(20, 235, (uint8_t*)"SISTEMA DE AUDIO:", Blue, White);
    if (audioHabilitado) {
        GUI_Text(160, 235, (uint8_t*)"[ ON ] ", Green, White);
    } else {
        GUI_Text(160, 235, (uint8_t*)"[ OFF ]", Red, White);
    }
    squareButton(&btn_Volver, "VOLVER", Black, Red);
    enable_critical_irqs();
}

void mostrarSeleccionRTC(void) {
    disable_critical_irqs();
    LCD_Clear(White);
    squareButton(&zone_titulo, "AJUSTE DE HORA", Black, Blue);
    enable_critical_irqs();
    
    sprintf(texto, "ANYO:%d", LPC_RTC->YEAR & 0x0FFF); 
    disable_critical_irqs(); squareButton(&btn_EditYear, texto, Black, Blue); enable_critical_irqs();
    
    sprintf(texto, "MES:%02d", (LPC_RTC->MONTH & 0x0F)); 
    disable_critical_irqs(); squareButton(&btn_EditMonth, texto, Black, Blue); enable_critical_irqs();
    
    sprintf(texto, "DIA:%02d", LPC_RTC->DOM & 0x3F); 
    disable_critical_irqs(); squareButton(&btn_EditDay, texto, Black, Blue); enable_critical_irqs();
    
    sprintf(texto, "HORA:%02d", LPC_RTC->HOUR & 0x1F); 
    disable_critical_irqs(); squareButton(&btn_EditHour, texto, Black, Blue); enable_critical_irqs();
    
    sprintf(texto, "MIN:%02d", LPC_RTC->MIN & 0x3F); 
    disable_critical_irqs(); squareButton(&btn_EditMin, texto, Black, Blue); enable_critical_irqs();
    
    disable_critical_irqs(); squareButton(&btn_Volver, "VOLVER", Red, Red); enable_critical_irqs();
}

void dibujarTeclado(void) {
    int k; char label[4];
    disable_critical_irqs();
    LCD_Clear(White);
    GUI_Text(60, 15, (uint8_t*)"INTRODUZCA VALOR:", Black, White);
    GUI_Text(110, 45, (uint8_t*)keypadBuffer, Red, White);
    enable_critical_irqs();
    
    for (k = 0; k < 12; k++) {
        keys[k].x = 45 + (k % 3) * 60; keys[k].y = 80 + (k / 3) * 45;
        keys[k].size_x = 50; keys[k].size_y = 35; keys[k].pressed = 0;
        if (k < 9) sprintf(label, "%d", k + 1);
        else if (k == 9) strcpy(label, "C");
        else if (k == 10) strcpy(label, "0");
        else strcpy(label, "OK");
        
        disable_critical_irqs(); // Protegemos tecla a tecla
        squareButton(&keys[k], label, Black, Blue);
        enable_critical_irqs();
    }
}

void mostrarModoConfig(void) {
    disable_critical_irqs();
    LCD_Clear(White);
    squareButton(&zone_titulo, "AJUSTES PWM", Black, Blue);
    enable_critical_irqs();
    
    sprintf(texto, "Servo: %3d      ", anguloServo); 
    disable_critical_irqs();
    escribirTextoDinamico(zone_servo_val.x + 10, zone_servo_val.y + 7, texto, Black, White);
    enable_critical_irqs();
    
    texto_brillo_anterior[0] = '\0';
    sprintf(texto, "Brillo: %3d%%     ", brilloDisplay); 
    disable_critical_irqs();
    escribirTextoDinamico(zone_brillo_val.x + 10, zone_brillo_val.y + 7, texto, Black, White);
    enable_critical_irqs();
    strcpy(texto_brillo_anterior, texto); 
    
    disable_critical_irqs();
    drawMinus(&btn_servo_dec, Black); 
    drawAdd(&btn_servo_inc, Black);
    drawMinus(&btn_brillo_dec, Black); 
    drawAdd(&btn_brillo_inc, Black);
    squareButton(&btn_Volver, "VOLVER", Red, Red);
    enable_critical_irqs();
}

/* --- PERIFÉRICOS --- */

void configPWM(void) {
    LPC_SC->PCONP |= (1<<6);        
    LPC_PINCON->PINSEL3 |= (2<<20); 
    LPC_PWM1->MR0 = Fpclk_pwm * Tpwm - 1; 
    LPC_PWM1->MR6 = (LPC_PWM1->MR0 * brilloDisplay) / 100; 
    LPC_PWM1->LER |= (1<<0) | (1<<6);
    LPC_PWM1->PCR |= (1<<14);         
    LPC_PWM1->TCR |= (1<<0) | (1<<3);             
}

void checkTouchPanel(void) {
    int i;
    // La lectura del TP a veces interfiere, pero menos. Si da problemas, añadir disable_critical_irqs()
    Coordinate* coord = Read_Ads7846();
    if (coord != NULL) {
        getDisplayPoint(&display, coord, &matrix); 
        pressedTouchPanel = 1;
    } else {
        pressedTouchPanel = 0;
        btn_GoNormal.pressed = 0; btn_GoConfig.pressed = 0; btn_GoRTC.pressed = 0; btn_Volver.pressed = 0;
        btn_EditYear.pressed = 0; btn_EditMonth.pressed = 0; btn_EditDay.pressed = 0; 
        btn_EditHour.pressed = 0; btn_EditMin.pressed = 0;
        btn_servo_dec.pressed = 0; btn_servo_inc.pressed = 0;
        btn_brillo_dec.pressed = 0; btn_brillo_inc.pressed = 0;
        for(i=0; i<12; i++) keys[i].pressed = 0;
    }
}

uint8_t leer_KEY1(void) {
    static uint8_t ultimo_estado = 1;
    int d;
    uint8_t estado_actual = (LPC_GPIO2->FIOPIN >> 11) & 0x01;
    if (ultimo_estado == 1 && estado_actual == 0) {
        for(d=0; d<10000; d++);
        ultimo_estado = estado_actual;
        return 1;
    }
    ultimo_estado = estado_actual;
    return 0;
}

void check_sensores(void){
    int tempEntera;
    char texto_nuevo[40];
    
    // Convertir lecturas a valores reales
    // NOTA: No actualizamos 'brilloDisplay' aquí todavía para evitar conflictos
    int lectura_potenciometro = (canal_0 * 100) / 4095; 
    
    milivoltios = (canal_1 * 3300.0) / 4095.0;
    Temperatura = milivoltios / 10.0;
    tempEntera = (int)Temperatura;

    // --- GESTIÓN DEL BRILLO (Lógica Protegida) ---
    // Solo permitimos que el potenciómetro cambie el brillo si NO estamos en Config
    // En Config, mandan los botones.
    if (estadoActual != ESTADO_MODO_CONFIG) {
        if (abs(lectura_potenciometro - brilloDisplay) > 1) {
            brilloDisplay = lectura_potenciometro;
        }
    }

    if ( brilloDisplay != ultimoBrillo ) { // Simplificado: si es distinto, actualizamos.
        
        // Saturación de seguridad (0 a 100)
        if (brilloDisplay > 100) brilloDisplay = 100;
        if (brilloDisplay < 0) brilloDisplay = 0;

        brilloTFT = brilloDisplay;
        
        // Actualización de registro PWM
        LPC_PWM1->MR6 = (LPC_PWM1->MR0 * brilloTFT) / 100;
        LPC_PWM1->LER |= (1<<6); 
        
        ultimoBrillo = brilloDisplay;
        
        // Si estamos en config, refrescamos el texto numérico del brillo
        if (estadoActual == ESTADO_MODO_CONFIG) {
            sprintf(texto_nuevo, "Brillo: %3d%%      ", brilloDisplay);
            // Solo redibujamos si el texto cambia realmente
            if (strcmp(texto_nuevo, texto_brillo_anterior) != 0) {
                disable_critical_irqs();
                escribirTextoDinamico(zone_brillo_val.x + 10, zone_brillo_val.y + 7, texto_nuevo, Black, White);
                enable_critical_irqs();
                strcpy(texto_brillo_anterior, texto_nuevo);
            }
        }
    }

    // --- GESTIÓN DE TEMPERATURA ---
    sprintf(texto_nuevo, "Temperatura: %5.1f C     ", Temperatura);
    
    if (estadoActual == ESTADO_MODO_NORMAL) {
        if (strcmp(texto_nuevo, texto_temp_anterior) != 0) {
            disable_critical_irqs();
            escribirTextoDinamico(30, 95, texto_nuevo, Black, White);
            enable_critical_irqs();
            strcpy(texto_temp_anterior, texto_nuevo);
        }
    }
}

/* -------- ADC TEMPERATURA  ---------*/
void init_ADC(void) {   
    LPC_SC->PCONP |= (1<<12); // Encender ADC
    
    // Configurar pines P0.23 (AD0.0) y P0.24 (AD0.1)
    LPC_PINCON->PINSEL1 |= ((1<<14)|(1<<16));
    LPC_PINCON->PINMODE1 |= ((2<<14)|(2<<16)); // Sin resistencias
    
    // Configurar reloj (sin seleccionar canales aún)
    // PDN=1, CLKDIV=1
    LPC_ADC->ADCR = (1<<8) | (1<<21); 
    
    // Habilitar interrupciones para Canal 0 y Canal 1 INDIVIDUALMENTE
    LPC_ADC->ADINTEN = (1<<0) | (1<<1);
    
    NVIC_EnableIRQ(ADC_IRQn);                   
    NVIC_SetPriority(ADC_IRQn, 6);              
}

void TIMER2_IRQHandler(void) {   
    // Limpiar flag del Timer
    LPC_TIM2->IR |= (1 << 0); 
    
    // PASO 1: Disparar SOLO el Canal 0 (Potenciómetro)
    // Limpiamos bits de selección anteriores (0xFFFFFF00) y seleccionamos Ch0
    // Bit 24 = START NOW
    LPC_ADC->ADCR = (LPC_ADC->ADCR & 0xFFFFFF00) | (1 << 0) | (1 << 24); 
}

void ADC_IRQHandler(void) {   
    // Leemos el registro de estado para saber qué canal ha terminado
    uint32_t stat = LPC_ADC->ADSTAT;

    // --- CASO 1: Terminó el Potenciómetro (Ch0) ---
    if (stat & (1 << 0)) {
        canal_0 = (LPC_ADC->ADDR0 >> 4) & 0xFFF; // Leer dato
        
        // PASO 2: Disparar inmediatamente el Canal 1 (Temperatura)
        LPC_ADC->ADCR = (LPC_ADC->ADCR & 0xFFFFFF00) | (1 << 1) | (1 << 24);
    }
    
    // --- CASO 2: Terminó la Temperatura (Ch1) ---
    else if (stat & (1 << 1)) {
        canal_1 = (LPC_ADC->ADDR1 >> 4) & 0xFFF; // Leer dato
        // Fin de la cadena. Esperamos al próximo Timer.
    }
}

void init_TIMER2(void) {
    //  Encender el periférico Timer 2
    LPC_SC->PCONP |= (1 << 22);       
    
    //  Configurar el Match Register 0 (MR0) para 50Hz (20ms)
    LPC_TIM2->MR0 = (F_pclk / F_muestreo) - 1;
    
    //  Configurar MCR: Interrupción y Reset en MR0
    LPC_TIM2->MCR = (1 << 0) | (1 << 1); 
    
    //  Arrancar el Timer
    LPC_TIM2->TCR = 0x01; 
    
    //  Habilitar interrupción en el NVIC
    NVIC_EnableIRQ(TIMER2_IRQn);      
    NVIC_SetPriority(TIMER2_IRQn, 5); 
}

/* --- MAIN LOOP --- */
int main(void) {
    int j;
    uint32_t last_sensor_check = 0;
    uint32_t last_touch_check = 0;

    LCD_Initializtion(); 
    LCD_Clear(White); 
    TP_Init();
    
    // Configuración de prioridades
    NVIC_SetPriorityGrouping(2);
    
    init_RTC();
    configPWM();
    // configGPIO(); 
    init_ADC();     
    init_TIMER2();  
    SysTick_config();
    
    mostrarMenuPrincipal();
        
    while(1) {
        
        // 1. GESTIÓN DE SENSORES (cada 200ms)
        if ( (ms_ticks - last_sensor_check) >= T_REFRESCO_SENSORES_MS ) {
            last_sensor_check = ms_ticks;
            
            check_sensores();
            
            if (leer_KEY1()) {
                audioHabilitado = !audioHabilitado;
                if (estadoActual == ESTADO_MODO_NORMAL) mostrarModoNormal();
            }
        }
        
        // 2. GESTIÓN DEL TÁCTIL (cada 50ms)
        if ( (ms_ticks - last_touch_check) >= T_REFRESCO_TOUCH_MS ) {
             checkTouchPanel();
             last_touch_check = ms_ticks;
        }

        // 3. CAMBIO DE MODO
        if (flag_toggle_config) {
            flag_toggle_config = 0; 
            if (estadoActual == ESTADO_MODO_CONFIG) {
                estadoActual = ESTADO_MENU_PRINCIPAL; 
                mostrarMenuPrincipal();
            } else {
                estadoActual = ESTADO_MODO_CONFIG;
                mostrarModoConfig();
                update_screen = 1; 
            }
        }

        // 4. RELOJ (cada segundo)
        if (flag_segundo) {
            flag_segundo = 0; 
            if (estadoActual == ESTADO_MENU_PRINCIPAL) actualizarRelojPantalla(20, 40, Black);
            else if (estadoActual == ESTADO_MODO_NORMAL) actualizarRelojPantalla(45, 40, Black);
        }

        // 5. MÁQUINA DE ESTADOS TÁCTIL
        if (pressedTouchPanel) {
            switch(estadoActual) {
                case ESTADO_MENU_PRINCIPAL:
                    if (zoneNewPressed(&btn_GoNormal)) { estadoActual = ESTADO_MODO_NORMAL; mostrarModoNormal(); }
                    else if (zoneNewPressed(&btn_GoConfig)) { estadoActual = ESTADO_MODO_CONFIG; mostrarModoConfig(); }
                    else if (zoneNewPressed(&btn_GoRTC)) { estadoActual = ESTADO_AJUSTE_RTC; mostrarSeleccionRTC(); }
                    break;

                case ESTADO_MODO_NORMAL:
                    if (zoneNewPressed(&btn_Volver)) { estadoActual = ESTADO_MENU_PRINCIPAL; mostrarMenuPrincipal(); }
                    break;

                case ESTADO_AJUSTE_RTC:
                    if (zoneNewPressed(&btn_Volver)) { estadoActual = ESTADO_MENU_PRINCIPAL; mostrarMenuPrincipal(); }
                    else if (zoneNewPressed(&btn_EditYear))  { parametroAEditar = EDIT_YEAR;  estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditMonth)) { parametroAEditar = EDIT_MONTH; estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditDay))   { parametroAEditar = EDIT_DOM;   estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditHour))  { parametroAEditar = EDIT_HOUR;  estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditMin))   { parametroAEditar = EDIT_MIN;   estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    break;

                case ESTADO_TECLADO:
                    for (j = 0; j < 12; j++) {
                        if (zoneNewPressed(&keys[j])) {
                            if (j < 9 || j == 10) { 
                                if (bufferIdx < 4) {
                                    keypadBuffer[bufferIdx] = (j == 10) ? '0' : (j + 1 + '0');
                                    bufferIdx++; keypadBuffer[bufferIdx] = '\0';
                                    dibujarTeclado(); 
                                }
                            } else if (j == 9) {
                                estadoActual = ESTADO_AJUSTE_RTC; mostrarSeleccionRTC();
                            } else if (j == 11) {
                                actualizarParametroRTC(); 
                                estadoActual = ESTADO_AJUSTE_RTC; mostrarSeleccionRTC();
                            }
                        }
                    }
                    break;

                case ESTADO_MODO_CONFIG:
                    if (zoneNewPressed(&btn_Volver)) { estadoActual = ESTADO_MENU_PRINCIPAL; mostrarMenuPrincipal(); }
                    else if (zoneNewPressed(&btn_servo_dec)) { if(anguloServo > 0) anguloServo-=5; update_screen=1; }
                    else if (zoneNewPressed(&btn_servo_inc)) { if(anguloServo < 180) anguloServo+=5; update_screen=1; }
                    else if (zoneNewPressed(&btn_brillo_dec)){ if(brilloDisplay > 0) brilloDisplay-=10; update_screen=1; }
                    else if (zoneNewPressed(&btn_brillo_inc)){ if(brilloDisplay < 100) brilloDisplay+=10; update_screen=1; }

                    if(update_screen) {
                        LPC_PWM1->MR6 = (LPC_PWM1->MR0 * brilloDisplay) / 100;
                        LPC_PWM1->LER |= (1<<6);
                        
                        sprintf(texto, "Servo: %3d      ", anguloServo); 
                        disable_critical_irqs(); // Bloqueo
                        escribirTextoDinamico(zone_servo_val.x + 10, zone_servo_val.y + 7, texto, Black, White);
                        
                        sprintf(texto, "Brillo: %3d%%     ", brilloDisplay); 
                        escribirTextoDinamico(zone_brillo_val.x + 10, zone_brillo_val.y + 7, texto, Black, White);
                        enable_critical_irqs();  // Desbloqueo
                        
                        strcpy(texto_brillo_anterior, texto);
                        
                        update_screen = 0; 
                    }
                    break;
            }
            pressedTouchPanel = 0; 
        }
    }
}
