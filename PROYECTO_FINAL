/********************************************************************************
 * PROYECTO: Sistema de Control SEDA 
 * DISPOSITIVO: NXP LPC1768
 * PROFESOR: LAB SEDA
 * INTEGRACIÓN: Servos PWM (Timer0) + Lógica IR + Audio + RFID + TFT
 ********************************************************************************/

#include <LPC17xx.H>
#include <glcd.h>
#include <TouchPanel.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "uart.h" /* Librería RFID */
#include <TCS34725.h>

#define F_sample 8000
#define N_muestras 12000 
#define UMBRAL_DETECCION 40  

/* --- DEFINICIONES DE TIMING --- */
#define T_REFRESCO_SENSORES_MS  200
#define T_REFRESCO_TOUCH_MS     50

/* --- DEFINICIONES DE HARDWARE Y RELOJES --- */
#define F_cpu 100000000UL                      
#define F_pclk (F_cpu/4)                 
#define F_wdclk F_pclk/4                
#define Fpclk_pwm 25e6                  
#define Tpwm  1e-3                      
#define F_muestreo 50

/* --- CONSTANTES RTC --- */
#define PCRTC 9                         
#define CLKEN 0                         
#define RTCIF 0                         
#define IMSEC 0                         
#define CCALEN 4  

#define PIN_IR_VERDE    (1 << 23) // P1.23
#define PIN_IR_NARANJA     (1 << 24) // P1.24

/* --- DEFINICIONES SERVOS (TIMER0) --- */
float TH_min = 0.5e-3;
float TH_max = 2.4e-3;
#define T_pwm 15e-3
#define T_PWM_MS_SERVO 20.0
#define TIEMPO_MANIOBRA_MS  600  // Tiempo que tarda el servo en llegar a la posición

/* --- ESTRUCTURAS Y TIPOS --- */
struct t_screenZone {
    uint16_t x; uint16_t y;
    uint16_t size_x;
    uint16_t size_y;
    uint8_t  pressed;
};

typedef enum { 
    ESTADO_MENU_PRINCIPAL, 
    ESTADO_MODO_NORMAL, 
    ESTADO_MODO_CONFIG,
    ESTADO_CONFIG_VERDE,    
    ESTADO_CONFIG_NARANJA,     
    ESTADO_AJUSTE_RTC,          
    ESTADO_TECLADO            
} t_EstadoSistema;

typedef enum {
    ESPERA_TRAMA,
    VALIDAR_CABECERA,
    EXTRAER_DATOS,
    ACTUALIZAR_DISPLAY
} EstadosRFID;

typedef enum { EDIT_NONE, EDIT_YEAR, EDIT_MONTH, EDIT_DOM, EDIT_HOUR, EDIT_MIN } t_EditParam;

/* --- VARIABLES GLOBALES --- */

const uint8_t TAG_REF[2][3] = {
    {132, 68, 53},  // TAG 1: NARANJA
    {53, 122, 61}     // TAG 2: Verde clarito
};

// Estados de la máquina de servos
typedef enum {
    SERVO_IDLE,       
    SERVO_MOVIENDO_IDA,   
    SERVO_MOVIENDO_VUELTA 
} t_EstadoServo;

// Estructura de control de servo individual
typedef struct {
    t_EstadoServo estado;
    uint32_t tiempo_inicio;
    uint8_t id; // 0=Verde, 1=Naranja
} t_ControlServo;

t_ControlServo servoVerde = {SERVO_IDLE, 0, 0};
t_ControlServo servoNaranja  = {SERVO_IDLE, 0, 1};

float TH0 = 0.5e-3;
float TH1 = 0.5e-3;

volatile uint8_t lcd_ocupado = 0; 
volatile uint8_t update_audio_ui = 0;

t_EstadoSistema estadoActual = ESTADO_MENU_PRINCIPAL;
t_EditParam parametroAEditar = EDIT_NONE;

volatile uint32_t ms_ticks = 0;
volatile uint8_t  flag_segundo = 0;

uint8_t update_screen = 0;
uint32_t contVerde = 0, contNaranja = 0; 
uint8_t  audioHabilitado = 0;           
float    Temperatura = 22.0;

int ultimoBrillo = -1;        
int ultimaTemp = -1;
int ultimoServo = -1;
float milivoltios = 0;
float brilloTFT = 0;

volatile uint32_t canal_0, canal_1;

uint8_t  pressedTouchPanel = 0;

int anguloServo = 90;   
int umbralTemperatura = 32;
int brilloDisplay = 50;            
char texto[40];
char texto_reloj_nuevo[40]; 

// Variables Teclado
char keypadBuffer[6]; 
uint8_t  bufferIdx = 0;
volatile uint8_t  flag_toggle_config = 0;

/* --- VARIABLES PARA GESTIÓN RFID --- */
uint8_t rfid_raw_data[5];
char rfid_string_display[13] = "---";
int k_rfid = 0; 
EstadosRFID estado_rfid = ESPERA_TRAMA;

/* --- VARIABLES AUDIO ---- */
volatile uint8_t audio_verde[N_muestras];
volatile uint8_t audio_Naranja[N_muestras];
volatile uint8_t *ptr_audio_activo = audio_verde;
volatile uint16_t indice_muestra;
volatile uint8_t estado_sistema = 0; // 0=IDLE, 1=REPRODUCIENDO, 2=GRABANDO
volatile uint8_t grabacion_completa = 0;

// Variables para la lógica de color
uint16_t raw_r, raw_g, raw_b, raw_c;
uint8_t final_r, final_g, final_b;
uint8_t ultimo_tag_detectado = 0;
uint8_t flag_objeto_presente = 0; 

// Buffers para evitar parpadeos
char texto_temp_anterior[40] = "";
char texto_brillo_anterior[40] = "";
char texto_reloj_anterior[40] = ""; 



/* --- ZONAS DE PANTALLA --- */
struct t_screenZone zone_titulo     = { 20,  5, 200, 30, 0};
struct t_screenZone btn_Volver      = { 10, 280, 80, 30, 0};
struct t_screenZone btn_GoNormal    = { 40,  60, 160, 60, 0};
struct t_screenZone btn_GoConfig    = { 40, 140, 160, 60, 0};
struct t_screenZone btn_GoRTC       = { 40, 220, 160, 60, 0};
struct t_screenZone btn_EditYear    = { 20,  50, 90, 40, 0};
struct t_screenZone btn_EditMonth   = { 130, 50, 90, 40, 0};
struct t_screenZone btn_EditDay     = { 20, 100, 90, 40, 0};
struct t_screenZone btn_EditHour    = { 130, 100, 90, 40, 0};
struct t_screenZone btn_EditMin     = { 75, 150, 90, 40, 0};
struct t_screenZone zone_servo_val = { 20,  40, 200, 30, 0};
struct t_screenZone btn_servo_dec  = { 30,  75,  50, 30, 0};
struct t_screenZone btn_servo_inc  = {170,  75,  50, 30, 0};
struct t_screenZone zone_brillo_val= { 20, 110, 200, 30, 0};
struct t_screenZone btn_brillo_dec = { 30, 145,  50, 30, 0};
struct t_screenZone btn_brillo_inc = {170, 145,  50, 30, 0};
struct t_screenZone btn_GoVerdeConfig = { 20, 180, 100, 40, 0};
struct t_screenZone btn_GoNaranjaConfig  = { 130, 180, 100, 40, 0};

struct t_screenZone keys[12];

/* --- PROTOTIPOS --- */
void init_ADC(void);
void init_ADC_microfono(void);

/* --- PROTECCIÓN DE PANTALLA ATÓMICA --- */
void disable_critical_irqs(void) {
    __disable_irq();
    lcd_ocupado = 1;
}

void enable_critical_irqs(void) {
    lcd_ocupado = 0;                
    __enable_irq();
}

void escribirTextoDinamico(uint16_t x, uint16_t y, char* str, uint16_t colorTexto, uint16_t colorFondo) {
    GUI_Text(x, y, (uint8_t*)str, colorTexto, colorFondo);
}

void SysTick_config(void) {
    SysTick->LOAD = 1000000 - 1; // 10ms
    SysTick->VAL = 0;
    SysTick->CTRL = (1 << 2) | (1 << 1) | (1 << 0);
    NVIC_SetPriority(SysTick_IRQn, 3);
}

void SysTick_Handler(void) {
    static uint16_t contador_pulsacion = 0;
    static uint8_t  bloqueo_evento = 0;
    static uint16_t contador_1s = 0;

    ms_ticks += 10; 

    contador_1s++;
    if (contador_1s >= 100) { 
        contador_1s = 0;
        flag_segundo = 1;
    }
    
    if ( (LPC_GPIO2->FIOPIN & (1 << 12)) == 0 ) {
        if (bloqueo_evento == 0) {
            contador_pulsacion++;
            if (contador_pulsacion >= 200) { 
                flag_toggle_config = 1;
                bloqueo_evento = 1;
            }
        }
    } 
    else {
        contador_pulsacion = 0;
        bloqueo_evento = 0;
    }
}

/* --- FUNCIONES RTC --- */
void set_time_default(void) {
    LPC_RTC->YEAR  = 2025;
    LPC_RTC->MONTH = 12; LPC_RTC->DOM = 22;
    LPC_RTC->HOUR  = 10;   LPC_RTC->MIN   = 0;  LPC_RTC->SEC = 0;
}

void init_RTC(void) {
    LPC_SC->PCONP |= (1<<9);
    LPC_RTC->CCR  = 0x00;
    LPC_RTC->CIIR = 0x00;
    LPC_RTC->AMR  = 0xFF;
    LPC_RTC->ILR  = 0x03;
    set_time_default();
    LPC_RTC->CCR = (1<<4);
    LPC_RTC->CIIR = (1<<0);
    NVIC_EnableIRQ(RTC_IRQn);
    LPC_RTC->CCR |= (1<<0);
}

void RTC_IRQHandler(void) {
    LPC_RTC->ILR |= 0x01;
}

void actualizarRelojPantalla(uint16_t x, uint16_t y, uint16_t colorTexto) {
    sprintf(texto_reloj_nuevo, "%02d/%02d/%d  %02d:%02d:%02d   ", 
            LPC_RTC->DOM & 0x3F, LPC_RTC->MONTH & 0x0F, LPC_RTC->YEAR & 0x0FFF, 
            LPC_RTC->HOUR & 0x1F, LPC_RTC->MIN & 0x3F, LPC_RTC->SEC & 0x3F);
    if (strcmp(texto_reloj_nuevo, texto_reloj_anterior) != 0) {
        disable_critical_irqs();
        escribirTextoDinamico(x, y, texto_reloj_nuevo, colorTexto, White);
        enable_critical_irqs();
        strcpy(texto_reloj_anterior, texto_reloj_nuevo);
    }
}

void actualizarParametroRTC(void) {
    int valor = atoi(keypadBuffer);
    LPC_RTC->CCR &= ~(1 << CLKEN);
    if (parametroAEditar == EDIT_YEAR)   { if(valor >= 2000 && valor <= 2099) LPC_RTC->YEAR = valor;}
    else if (parametroAEditar == EDIT_MONTH) { if(valor >= 1 && valor <= 12) LPC_RTC->MONTH = valor;}
    else if (parametroAEditar == EDIT_DOM)   { if(valor >= 1 && valor <= 31)    LPC_RTC->DOM = valor;}
    else if (parametroAEditar == EDIT_HOUR)  { if(valor >= 0 && valor <= 23)    LPC_RTC->HOUR = valor;}
    else if (parametroAEditar == EDIT_MIN)   { if(valor >= 0 && valor <= 59)    LPC_RTC->MIN = valor;}
    LPC_RTC->CCR |= (1 << CLKEN);
}

/* --- FUNCIONES GRÁFICAS --- */
void squareButton(struct t_screenZone* zone, char * text, uint16_t textColor, uint16_t lineColor) {
    LCD_DrawLine(zone->x - 5, zone->y, zone->x + zone->size_x + 5, zone->y, lineColor);
    LCD_DrawLine(zone->x - 5, zone->y, zone->x - 5, zone->y + zone->size_y, lineColor);
    LCD_DrawLine(zone->x - 5, zone->y + zone->size_y, zone->x + zone->size_x + 5, zone->y + zone->size_y, lineColor);
    LCD_DrawLine(zone->x + zone->size_x + 5, zone->y, zone->x + zone->size_x + 5, zone->y + zone->size_y, lineColor);
    GUI_Text(zone->x + zone->size_x/2 - (strlen(text)/2)*8, zone->y + zone->size_y/2 - 8, (uint8_t*) text, textColor, White);
}

void drawMinus(struct t_screenZone* zone, uint16_t lineColor) {
    LCD_DrawLine(zone->x + 5, zone->y + zone->size_y/2, zone->x + zone->size_x - 5, zone->y + zone->size_y/2, lineColor);
}

void drawAdd(struct t_screenZone* zone, uint16_t lineColor) {
    drawMinus(zone, lineColor);
    LCD_DrawLine(zone->x + zone->size_x/2, zone->y + 5, zone->x + zone->size_x/2, zone->y + zone->size_y - 5, lineColor);
}

int8_t zoneNewPressed(struct t_screenZone* zone) {
    if (pressedTouchPanel == 1 && zone->pressed == 0) {
        if ((display.x > zone->x) && (display.x < zone->x + zone->size_x) && 
            (display.y > zone->y) && (display.y < zone->y + zone->size_y)) {
            zone->pressed = 1;
            return 1;
        }
    }
    return 0;
}

/* --- DIBUJO DE PANTALLAS --- */
void mostrarMenuPrincipal(void) {
    disable_critical_irqs(); 
    LCD_Clear(White); 
    enable_critical_irqs();
    
    disable_critical_irqs();
    squareButton(&zone_titulo, "MENU PRINCIPAL", Black, Red); enable_critical_irqs();
    disable_critical_irqs(); squareButton(&btn_GoNormal, "MODO NORMAL", Black, Red); enable_critical_irqs();
    disable_critical_irqs(); squareButton(&btn_GoConfig, "MODO CONFIGURACION", Black, Red); enable_critical_irqs();
    disable_critical_irqs(); squareButton(&btn_GoRTC, "AJUSTE FECHA/HORA", Black, Red); enable_critical_irqs();
    
    sprintf(texto_reloj_nuevo, "%02d/%02d/%d  %02d:%02d:%02d   ", 
            LPC_RTC->DOM & 0x3F, LPC_RTC->MONTH & 0x0F, LPC_RTC->YEAR & 0x0FFF, 
            LPC_RTC->HOUR & 0x1F, LPC_RTC->MIN & 0x3F, LPC_RTC->SEC & 0x3F);
    disable_critical_irqs(); escribirTextoDinamico(20, 40, texto_reloj_nuevo, Black, White); enable_critical_irqs();
    strcpy(texto_reloj_anterior, texto_reloj_nuevo);
    texto_temp_anterior[0] = '\0';
    texto_brillo_anterior[0] = '\0';
}

void mostrarModoNormal(void) {
    disable_critical_irqs(); LCD_Clear(White); squareButton(&zone_titulo, "MODO NORMAL", Black, Blue); enable_critical_irqs();
    
    texto_reloj_anterior[0] = '\0';
    sprintf(texto_reloj_nuevo, "%02d/%02d/%d  %02d:%02d:%02d   ", 
            LPC_RTC->DOM & 0x3F, LPC_RTC->MONTH & 0x0F, LPC_RTC->YEAR & 0x0FFF, 
            LPC_RTC->HOUR & 0x1F, LPC_RTC->MIN & 0x3F, LPC_RTC->SEC & 0x3F);
    disable_critical_irqs();
    escribirTextoDinamico(45, 40, texto_reloj_nuevo, Black, White);
    LCD_DrawLine(10, 65, 230, 65, Blue);
		sprintf(texto, "UMBRAL TEMPERATURA: %d C  ", umbralTemperatura);
		GUI_Text(20, 75, (uint8_t*)texto, Red, White);
    enable_critical_irqs();
    texto_temp_anterior[0] = '\0'; 
    
    sprintf(texto, "RFID: %s       ", rfid_string_display);
    disable_critical_irqs(); GUI_Text(30, 115, (uint8_t*)texto, Black, White);
    LCD_DrawLine(10, 145, 230, 145, Blue);
    GUI_Text(20, 155, (uint8_t*)"OBJETOS PROCESADOS:", Blue, White); enable_critical_irqs();

    LCD_DrawLine(10, 145, 230, 145, Blue);
    
    sprintf(texto, "VERDES: %d  ", contVerde);
    disable_critical_irqs();
    GUI_Text(40, 175, (uint8_t*)texto, Green, White); enable_critical_irqs();
    
    sprintf(texto, "NARANJAS: %d  ", contNaranja);
    disable_critical_irqs(); GUI_Text(40, 195, (uint8_t*)texto, Orange, White); enable_critical_irqs();

    disable_critical_irqs();
    LCD_DrawLine(10, 225, 230, 225, Blue);
    GUI_Text(20, 235, (uint8_t*)"SISTEMA DE AUDIO:", Blue, White);
    if (audioHabilitado) { GUI_Text(160, 235, (uint8_t*)"[ ON ] ", Green, White);
    } else { GUI_Text(160, 235, (uint8_t*)"[ OFF ]", Red, White); }
    squareButton(&btn_Volver, "VOLVER", Black, Red);
    enable_critical_irqs();
}

void mostrarSeleccionRTC(void) {
    disable_critical_irqs(); LCD_Clear(White); squareButton(&zone_titulo, "AJUSTE DE HORA", Black, Blue); enable_critical_irqs();
    
    sprintf(texto, "ANYO:%d", LPC_RTC->YEAR & 0x0FFF);
    disable_critical_irqs(); squareButton(&btn_EditYear, texto, Black, Blue); enable_critical_irqs();
    sprintf(texto, "MES:%02d", (LPC_RTC->MONTH & 0x0F)); 
    disable_critical_irqs(); squareButton(&btn_EditMonth, texto, Black, Blue); enable_critical_irqs();
    sprintf(texto, "DIA:%02d", LPC_RTC->DOM & 0x3F); 
    disable_critical_irqs(); squareButton(&btn_EditDay, texto, Black, Blue); enable_critical_irqs();
    sprintf(texto, "HORA:%02d", LPC_RTC->HOUR & 0x1F); 
    disable_critical_irqs();
    squareButton(&btn_EditHour, texto, Black, Blue); enable_critical_irqs();
    sprintf(texto, "MIN:%02d", LPC_RTC->MIN & 0x3F); 
    disable_critical_irqs(); squareButton(&btn_EditMin, texto, Black, Blue); enable_critical_irqs();
    disable_critical_irqs();
    squareButton(&btn_Volver, "VOLVER", Red, Red); enable_critical_irqs();
}

void dibujarTeclado(void) {
    int k; char label[4];
    disable_critical_irqs(); LCD_Clear(White);
    GUI_Text(60, 15, (uint8_t*)"INTRODUZCA VALOR:", Black, White); GUI_Text(110, 45, (uint8_t*)keypadBuffer, Red, White); enable_critical_irqs();
    for (k = 0; k < 12; k++) {
        keys[k].x = 45 + (k % 3) * 60;
        keys[k].y = 80 + (k / 3) * 45;
        keys[k].size_x = 50; keys[k].size_y = 35; keys[k].pressed = 0;
        if (k < 9) sprintf(label, "%d", k + 1); else if (k == 9) strcpy(label, "C");
        else if (k == 10) strcpy(label, "0"); else strcpy(label, "OK");
        disable_critical_irqs(); squareButton(&keys[k], label, Black, Blue); enable_critical_irqs();
    }
}

void mostrarModoConfig(void) {
    disable_critical_irqs(); LCD_Clear(White); squareButton(&zone_titulo, "CONFIG GENERAL", Black, Blue); enable_critical_irqs();
    sprintf(texto, "Servo: %3d      ", anguloServo); 
    disable_critical_irqs();
    escribirTextoDinamico(zone_servo_val.x + 10, zone_servo_val.y + 7, texto, Black, White); enable_critical_irqs();
    sprintf(texto, "Brillo: %3d%%     ", brilloDisplay); 
    disable_critical_irqs();
    escribirTextoDinamico(zone_brillo_val.x + 10, zone_brillo_val.y + 7, texto, Black, White); enable_critical_irqs();
    strcpy(texto_brillo_anterior, texto); 
    disable_critical_irqs(); drawMinus(&btn_servo_dec, Black); drawAdd(&btn_servo_inc, Black); drawMinus(&btn_brillo_dec, Black);
    drawAdd(&btn_brillo_inc, Black); enable_critical_irqs();

    disable_critical_irqs();
    LCD_DrawLine(10, 175, 230, 175, Blue);
    squareButton(&btn_GoVerdeConfig, "CONF VERDE", Black, Green);
    squareButton(&btn_GoNaranjaConfig,  "CONF ROSA",  Black, Orange);
    squareButton(&btn_Volver, "VOLVER", Red, Red);
    enable_critical_irqs();
}

void mostrarSubMenuColor(char* titulo, uint16_t color) {
    disable_critical_irqs();
    LCD_Clear(White);
    squareButton(&zone_titulo, titulo, Black, color);
    GUI_Text(20, 60, (uint8_t*)"USE BOTONES:", Black, White);
    GUI_Text(20, 90, (uint8_t*)"KEY2: GRABAR", Red, White);
    GUI_Text(20, 120, (uint8_t*)"KEY1: REPRODUCIR", Blue, White);
    squareButton(&btn_Volver, "VOLVER", Black, Red);
    enable_critical_irqs();
}

/* --- PERIFÉRICOS --- */

void configPWM(void) {
    LPC_SC->PCONP |= (1<<6);        
    LPC_PINCON->PINSEL3 |= (2<<20);
    LPC_PWM1->MR0 = Fpclk_pwm * Tpwm - 1; 
    LPC_PWM1->MR6 = (LPC_PWM1->MR0 * brilloDisplay) / 100; 
    LPC_PWM1->LER |= (1<<0) | (1<<6);
    LPC_PWM1->PCR |= (1<<14);           
    LPC_PWM1->TCR |= (1<<0) | (1<<3);               
}

void checkTouchPanel(void) {
    int i;
    Coordinate* coord = Read_Ads7846();
    if (coord != NULL) {
        getDisplayPoint(&display, coord, &matrix); 
        pressedTouchPanel = 1;
    } else {
        pressedTouchPanel = 0;
        btn_GoNormal.pressed = 0;
        btn_GoConfig.pressed = 0; btn_GoRTC.pressed = 0; btn_Volver.pressed = 0;
        btn_EditYear.pressed = 0; btn_EditMonth.pressed = 0; btn_EditDay.pressed = 0;
        btn_EditHour.pressed = 0; btn_EditMin.pressed = 0;
        btn_servo_dec.pressed = 0; btn_servo_inc.pressed = 0;
        btn_brillo_dec.pressed = 0; btn_brillo_inc.pressed = 0;
        btn_GoVerdeConfig.pressed = 0; btn_GoNaranjaConfig.pressed = 0;
        for(i=0; i<12; i++) keys[i].pressed = 0;
    }
}

void check_sensores(void){
    int tempEntera;
    char texto_nuevo[40];
    
    int lectura_potenciometro = (canal_0 * 100) / 4095;
    milivoltios = (canal_1 * 3300.0) / 4095.0;
    Temperatura = milivoltios / 10.0;
    tempEntera = (int)Temperatura;

    if (estadoActual != ESTADO_MODO_CONFIG) {
        if (abs(lectura_potenciometro - brilloDisplay) > 1) {
            brilloDisplay = lectura_potenciometro;
        }
    }

    if ( brilloDisplay != ultimoBrillo ) { 
        if (brilloDisplay > 100) brilloDisplay = 100;
        if (brilloDisplay < 0) brilloDisplay = 0;
        brilloTFT = brilloDisplay;
        LPC_PWM1->MR6 = (LPC_PWM1->MR0 * brilloTFT) / 100;
        LPC_PWM1->LER |= (1<<6);
        ultimoBrillo = brilloDisplay;
        
        if (estadoActual == ESTADO_MODO_CONFIG) {
            sprintf(texto_nuevo, "Brillo: %3d%%      ", brilloDisplay);
            if (strcmp(texto_nuevo, texto_brillo_anterior) != 0) {
                disable_critical_irqs();
                escribirTextoDinamico(zone_brillo_val.x + 10, zone_brillo_val.y + 7, texto_nuevo, Black, White);
                enable_critical_irqs();
                strcpy(texto_brillo_anterior, texto_nuevo);
            }
        }
    }

    sprintf(texto_nuevo, "Temperatura: %5.1f C      ", Temperatura);
    if (estadoActual == ESTADO_MODO_NORMAL) {
        if (strcmp(texto_nuevo, texto_temp_anterior) != 0) {
            disable_critical_irqs();
            escribirTextoDinamico(30, 95, texto_nuevo, Black, White);
            enable_critical_irqs();
            strcpy(texto_temp_anterior, texto_nuevo);
        }
    }
}

/* -------- HARDWARE AUDIO ---------*/
void init_DAC(void) {
    LPC_PINCON->PINSEL1 &= ~(3 << 20);
    LPC_PINCON->PINSEL1 |= (2 << 20);  
    LPC_PINCON->PINMODE1 |= (2 << 20);
    LPC_DAC->DACCTRL = 0;
}

void init_ADC_microfono(void) {
    LPC_SC->PCONP |= (1 << 12); 
    LPC_PINCON->PINSEL1 &= ~(3 << 18);
    LPC_PINCON->PINSEL1 |= (1 << 18); 
    LPC_PINCON->PINMODE1 &= ~(3 << 18); LPC_PINCON->PINMODE1 |= (2 << 18);
    LPC_ADC->ADCR = (1 << 2) | (1 << 8) | (1 << 21) | (7 << 24);
    LPC_ADC->ADINTEN = (1 << 2); 
    NVIC_EnableIRQ(ADC_IRQn); NVIC_SetPriority(ADC_IRQn, 0); 
}

void init_ADC(void) {   
    LPC_SC->PCONP |= (1<<12);
    LPC_PINCON->PINSEL1 |= ((1<<14)|(1<<16));
    LPC_PINCON->PINMODE1 |= ((2<<14)|(2<<16)); 
    LPC_ADC->ADCR = (1<<8) | (1<<21); 
    LPC_ADC->ADINTEN = (1<<0) | (1<<1);
    NVIC_EnableIRQ(ADC_IRQn); NVIC_SetPriority(ADC_IRQn, 6);
}

void TIMER2_IRQHandler(void) {   
    LPC_TIM2->IR |= (1 << 0); 
    if (estado_sistema == 2) return;
    LPC_ADC->ADCR = (LPC_ADC->ADCR & 0xFFFFFF00) | (1 << 0) | (1 << 24);
}

void ADC_IRQHandler(void) {    
    uint32_t stat = LPC_ADC->ADSTAT;
    if (stat & (1 << 2)) {
        uint8_t valor_audio = (LPC_ADC->ADDR2 >> 8) & 0xFF;
        ptr_audio_activo[indice_muestra++] = valor_audio;
        if (indice_muestra >= N_muestras) {
            LPC_TIM1->TCR = 0x02;
            estado_sistema = 0;      
            grabacion_completa = 1;  
            indice_muestra = 0;      
            init_ADC();       
            LPC_TIM2->TCR = 0x01;
        }
    }
    else if (stat & (1 << 0)) {
        canal_0 = (LPC_ADC->ADDR0 >> 4) & 0xFFF;
        if (estado_sistema != 2) LPC_ADC->ADCR = (LPC_ADC->ADCR & 0xFFFFFF00) | (1 << 1) | (1 << 24);
    }
    else if (stat & (1 << 1)) {
        canal_1 = (LPC_ADC->ADDR1 >> 4) & 0xFFF;
    }
}

void init_TIMER2(void) {
    LPC_SC->PCONP |= (1 << 22); LPC_TIM2->MR0 = (F_pclk / F_muestreo) - 1;
    LPC_TIM2->MCR = (1 << 0) | (1 << 1); LPC_TIM2->TCR = 0x01; 
    NVIC_EnableIRQ(TIMER2_IRQn); NVIC_SetPriority(TIMER2_IRQn, 5);
}

/* ---------- LOGICA SERVOS (TIMER0) ------------*/
void init_TIMER0(void) {
    LPC_SC->PCONP |= (1 << 1);

    LPC_TIM0->TCR = 0x02; 
    LPC_TIM0->PR  = 0;    
    LPC_TIM0->MR0 = F_pclk * 15e-3; 
    LPC_TIM0->MR1 = F_pclk * 15e-3;
    LPC_TIM0->EMR = (3 << 4) | (3 << 6); // Toggle
    LPC_TIM0->MCR = (1 << 0) | (1 << 3); 
    LPC_TIM0->TCR = 0x01; 
    NVIC_EnableIRQ(TIMER0_IRQn);
}

void TIMER0_IRQHandler(void) {
    // Servo 1 (Verde)
    if (LPC_TIM0->IR & (1 << 0)) { 
        LPC_TIM0->IR |= (1 << 0);
        if (LPC_TIM0->EMR & (1 << 0)) LPC_TIM0->MR0 = LPC_TIM0->MR0 + (TH0*F_pclk-1);
        else LPC_TIM0->MR0 = LPC_TIM0->MR0 + ((T_pwm-TH0)*F_pclk-1);
    }
    // Servo 2 (Naranja)
    if (LPC_TIM0->IR & (1 << 1)) {
        LPC_TIM0->IR |= (1 << 1);
        if (LPC_TIM0->EMR & (1 << 1)) LPC_TIM0->MR1 = LPC_TIM0->MR1 + (TH1*F_pclk-1);
        else LPC_TIM0->MR1 = LPC_TIM0->MR1 + ((T_pwm-TH1)*F_pclk-1);
    }
}

void set_th_servo(uint8_t id, float grados) {
    float nuevo_TH;
		// Limitar rango por seguridad mecánica
    if (grados < 0) grados = 0;
    if (grados > 180) grados = 180;
    
    // Cálculo del tiempo en alto (Duty Cycle)
    nuevo_TH = TH_min + (TH_max - TH_min) * (grados / 180.0f);
    
    // Actualizar variables globales VOLÁTILES
    if (id == 0) TH0 = nuevo_TH;
    else         TH1 = nuevo_TH;
}

/* Máquina de estados para mover servos sin bloqueo */
void procesar_maquina_servos(t_ControlServo *servo) {
    switch(servo->estado) {
        case SERVO_IDLE:
            break;
            
        case SERVO_MOVIENDO_IDA:
            // El servo va hacia 180. Esperamos 500ms.
            if ((ms_ticks - servo->tiempo_inicio) >= 500) {
                // Pasó el tiempo, volver a 0 (REPOSO)
                set_th_servo(servo->id, 0); 
                servo->tiempo_inicio = ms_ticks;
                servo->estado = SERVO_MOVIENDO_VUELTA;
            }
            break;
            
        case SERVO_MOVIENDO_VUELTA:
            // El servo vuelve a 0. Esperamos 500ms.
            if ((ms_ticks - servo->tiempo_inicio) >= 500) {
                // Movimiento terminado
                servo->estado = SERVO_IDLE;
            }
            break;
    }
}

// Función para DISPARAR la secuencia (solo da la orden inicial)
void disparar_servo(t_ControlServo *servo) {
    if (servo->estado == SERVO_IDLE) {
        set_th_servo(servo->id, 180); // Mover a posición extendida
        servo->tiempo_inicio = ms_ticks;
        servo->estado = SERVO_MOVIENDO_IDA;
    }
}

/* ---------- LOGICA AUDIO ------------*/
void iniciar_grabacion_color(volatile uint8_t *buffer_destino) {
    LPC_TIM2->TCR = 0x00;
    ptr_audio_activo = buffer_destino;
    estado_sistema = 2; 
    indice_muestra = 0;
    init_ADC_microfono();
    LPC_TIM1->TCR = 0x02;
    LPC_TIM1->TCR = 0x01; 
}

void iniciar_reproduccion_color(volatile uint8_t *buffer_origen) {
    ptr_audio_activo = buffer_origen;
    estado_sistema = 1; 
    indice_muestra = 0;
    LPC_TIM3->TCR = 0x02; LPC_TIM3->TCR = 0x01;
}

void TIMER3_IRQHandler(void) {
    LPC_TIM3->IR |= (1<<0); 
    LPC_DAC->DACR = ptr_audio_activo[indice_muestra++] << 8;
    if(indice_muestra >= N_muestras){
        indice_muestra = 0;
        LPC_TIM3->TCR = 0x02; 
        LPC_DAC->DACR = 0;
        estado_sistema = 0;   
    }
}   

void init_TIMER1(void) {
    LPC_SC->PCONP |= (1<<2); 
    LPC_PINCON->PINSEL3 &= ~(3 << 18);
    LPC_PINCON->PINSEL3 |= (3 << 18); 
    LPC_TIM1->MR1 = (F_pclk / (F_sample * 2)) - 1; 
    LPC_TIM1->MCR = (1 << 4);
    LPC_TIM1->EMR |= (3 << 6); 
    LPC_TIM1->TCR = 0x02;
}

void init_TIMER3(void) {
    LPC_SC->PCONP |= (1<<23);
    LPC_TIM3->MR0 = (F_pclk / F_sample ) - 1; 
    LPC_TIM3->MCR = 0x03; LPC_TIM3->TCR = 0x02; 
    NVIC_EnableIRQ(TIMER3_IRQn); NVIC_SetPriority(TIMER3_IRQn, 0);
}

void init_Externas() {
    LPC_PINCON->PINSEL4 |= (1<<22); LPC_SC->EXTMODE |= (1<<1); NVIC_EnableIRQ(EINT1_IRQn);
    LPC_PINCON->PINSEL4 |= (1<<24); LPC_SC->EXTMODE |= (1<<2);
    LPC_SC->EXTPOLAR &= ~(1<<2); NVIC_EnableIRQ(EINT2_IRQn);
}

void EINT1_IRQHandler(void) {
    LPC_SC->EXTINT |= (1 << 1);
    switch(estadoActual) {
        case ESTADO_MODO_NORMAL:
            audioHabilitado = !audioHabilitado;
            update_audio_ui = 1; 
            break;
        case ESTADO_CONFIG_VERDE:
        case ESTADO_CONFIG_NARANJA:
            if (estado_sistema == 0) {
                iniciar_reproduccion_color(ptr_audio_activo);
            }
            break;
        default: break;
    }
}

void EINT2_IRQHandler(void) { 
    LPC_SC->EXTINT |= (1 << 2);
    if (estado_sistema == 0) iniciar_grabacion_color(ptr_audio_activo);
}

/* --- FUNCIONES DE COLOR --- */
uint8_t saturar_valor(uint32_t valor) {
    if (valor > 255) return 255;
    return (uint8_t)valor;
}

uint8_t identificarTag(uint8_t r, uint8_t g, uint8_t b) {
    int i;
    int32_t diff;
    int32_t min_diff = 10000; 
    uint8_t id_detectado = 0;
    if (r < 20 && g < 20 && b < 20) return 0;
    for(i = 0; i < 2; i++) {
        int dr = abs((int)r - (int)TAG_REF[i][0]);
        int dg = abs((int)g - (int)TAG_REF[i][1]);
        int db = abs((int)b - (int)TAG_REF[i][2]);
        diff = dr + dg + db;
        if (diff < min_diff) {
            min_diff = diff;
            if (diff < UMBRAL_DETECCION) {
                id_detectado = i + 1;
            }
        }
    }
    return id_detectado;
}

void procesar_sensor_color(void) {
    uint32_t temp_r, temp_g, temp_b; uint8_t tag_actual;
    TCS34725_getRawData(&raw_r, &raw_g, &raw_b, &raw_c);
    if (raw_c > 0) {
        temp_r = (raw_r * 255) / raw_c;
        temp_g = (raw_g * 255) / raw_c; temp_b = (raw_b * 255) / raw_c;
        final_r = saturar_valor(temp_r); final_g = saturar_valor(temp_g);
        final_b = saturar_valor(temp_b);
    } else { final_r = 0; final_g = 0; final_b = 0;
    }

    tag_actual = identificarTag(final_r, final_g, final_b);
    
    if (estadoActual == ESTADO_MODO_NORMAL) {
        char txt_debug[40];
        sprintf(txt_debug, "R:%03d G:%03d B:%03d   ", final_r, final_g, final_b);
        disable_critical_irqs(); GUI_Text(10, 260, (uint8_t*)txt_debug, Black, White); enable_critical_irqs();
    }
        
    if (tag_actual != 0 && flag_objeto_presente == 0) {
        flag_objeto_presente = 1;
        ultimo_tag_detectado = tag_actual;

        if (tag_actual == 1) { // Naranja
            contNaranja++;
            if (audioHabilitado && estado_sistema == 0) {
                iniciar_reproduccion_color(audio_Naranja);
            }
        } 
        else if (tag_actual == 2) { // VERDE
            contVerde++;
            if (audioHabilitado && estado_sistema == 0) {
                iniciar_reproduccion_color(audio_verde);
            }
        }
        
        if (estadoActual == ESTADO_MODO_NORMAL) mostrarModoNormal();
    } 
    else if (tag_actual == 0) {
        flag_objeto_presente = 0;
    }
}

/* --- INICIALIZACIÓN DE SENSORES IR --- */
void init_IR_Sensores(void) {
    LPC_PINCON->PINSEL3 &= ~((3UL << 14) | (3UL << 16));
    LPC_GPIO1->FIODIR &= ~(PIN_IR_VERDE | PIN_IR_NARANJA);
    LPC_PINCON->PINMODE3 &= ~((3UL << 14) | (3UL << 16));
}

uint8_t leerSensorVerde(void) {
    // Leemos del PUERTO 1
    if ( (LPC_GPIO1->FIOPIN & PIN_IR_VERDE) == 0 ) {
        return 1; // 0 = Detectado
    }
    return 0;
}

uint8_t leerSensorNaranja(void) {
    // Leemos del PUERTO 1
    if ( (LPC_GPIO1->FIOPIN & PIN_IR_NARANJA) == 0 ) {
        return 1; // 0 = Detectado
    }
    return 0;
}

/* --- MAIN LOOP --- */
int main(void) {
		int j;
	
    LCD_Initializtion(); 
    LCD_Clear(White); 
    TP_Init(); 
    NVIC_SetPriorityGrouping(2);
    
    // --- Configuración Pines Servos (P3.25/26) ---
    LPC_PINCON->PINSEL7 |= (2<<18); // P3.25 -> MAT0.0
    LPC_PINCON->PINSEL7 |= (2<<20); // P3.26 -> MAT0.1
	
		set_th_servo(0, 0); // Servo Verde a 0 grados
    set_th_servo(1, 0); // Servo Naranja a 0 grados
    
    // --- Inicialización del Sistema ---
    init_RTC(); 
    configPWM(); 
    init_Externas(); 
    init_IR_Sensores(); // Configura P1.23 y P1.24
    init_TIMER0();      // Timer Servos
    init_ADC(); 
    init_DAC(); 
    TCS34725_init(); 
    TCS34725_enable();
    init_TIMER1(); 
    init_TIMER2(); 
    init_TIMER3(); 
    SysTick_config();
    uart3_init(9600); 
    ptr_rx = buffer;

   

    mostrarMenuPrincipal();

    while(1) {
        if (estado_sistema != 0) continue;

        // 1. Mover Servos (Máquina de Estados)
        procesar_maquina_servos(&servoVerde);
        procesar_maquina_servos(&servoNaranja);

        // 2. Disparo por Sensores (Leemos LPC_GPIO1)
        if (leerSensorVerde())   disparar_servo(&servoVerde);
        if (leerSensorNaranja()) disparar_servo(&servoNaranja);

       

        // 4. RFID
        switch(estado_rfid) {
            case ESPERA_TRAMA: 
                if(rx_completa) { 
                    rx_completa = 0; 
                    estado_rfid = VALIDAR_CABECERA; 
                } 
                break;
            case VALIDAR_CABECERA: 
                if(buffer[0] == 0x02) {
                    estado_rfid = EXTRAER_DATOS; 
                } else { 
                    ptr_rx = buffer; 
                    estado_rfid = ESPERA_TRAMA; 
                } 
                break;
            case EXTRAER_DATOS: 
							if(buffer[9] == 0x00) { 
								for(k_rfid=0; k_rfid<5; k_rfid++) 
									rfid_raw_data[k_rfid] = buffer[3+k_rfid]; 
										estado_rfid = ACTUALIZAR_DISPLAY; 
							} else { 
										ptr_rx = buffer; 
										estado_rfid = ESPERA_TRAMA; 
							} 
							break;

            case ACTUALIZAR_DISPLAY: 
                sprintf(rfid_string_display, "%02X%02X%02X%02X%02X", rfid_raw_data[0], rfid_raw_data[1], rfid_raw_data[2], rfid_raw_data[3], rfid_raw_data[4]);
                if (estadoActual == ESTADO_MODO_NORMAL) { 
                    disable_critical_irqs(); 
                    sprintf(texto, "RFID: %s       ", rfid_string_display); 
                    escribirTextoDinamico(30, 115, texto, Black, White); 
                    enable_critical_irqs(); 
                }
                ptr_rx = buffer; 
                estado_rfid = ESPERA_TRAMA; 
                break;
        }

        // 5. Check Sensores Lentos (Temp / Color)
        if ((ms_ticks % T_REFRESCO_SENSORES_MS) == 0) { 
            check_sensores(); 
            procesar_sensor_color();
        }
        
        // 6. Check Panel Táctil
        if ((ms_ticks % T_REFRESCO_TOUCH_MS) == 0) { 
            checkTouchPanel(); 
        }
        
        // 7. UI Audio
        if (update_audio_ui && estadoActual == ESTADO_MODO_NORMAL) {
            disable_critical_irqs();
            if (audioHabilitado) {
                GUI_Text(160, 235, (uint8_t*)"[ ON ] ", Green, White);
            } else {
                GUI_Text(160, 235, (uint8_t*)"[ OFF ]", Red, White);
            }
            enable_critical_irqs(); 
            update_audio_ui = 0;
        }
        
        // 8. Reloj
        if (flag_segundo) {
            flag_segundo = 0;
            if (estadoActual == ESTADO_MENU_PRINCIPAL) actualizarRelojPantalla(20, 40, Black);
            else if (estadoActual == ESTADO_MODO_NORMAL) actualizarRelojPantalla(45, 40, Black);
        }

        // 9. Gestión de Menús (Táctil)
        if (pressedTouchPanel) {
             switch(estadoActual) {
                case ESTADO_MENU_PRINCIPAL:
                    if (zoneNewPressed(&btn_GoNormal)) { estadoActual = ESTADO_MODO_NORMAL; mostrarModoNormal(); }
                    else if (zoneNewPressed(&btn_GoConfig)) { estadoActual = ESTADO_MODO_CONFIG; mostrarModoConfig(); }
                    else if (zoneNewPressed(&btn_GoRTC)) { estadoActual = ESTADO_AJUSTE_RTC; mostrarSeleccionRTC(); }
                    break;
                
                case ESTADO_MODO_NORMAL:
                    if (zoneNewPressed(&btn_Volver)) { estadoActual = ESTADO_MENU_PRINCIPAL; mostrarMenuPrincipal(); }
                    break;
                
                case ESTADO_AJUSTE_RTC:
                    if (zoneNewPressed(&btn_Volver)) { estadoActual = ESTADO_MENU_PRINCIPAL; mostrarMenuPrincipal(); }
                    else if (zoneNewPressed(&btn_EditYear))  { parametroAEditar = EDIT_YEAR; estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditMonth)) { parametroAEditar = EDIT_MONTH; estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditDay))   { parametroAEditar = EDIT_DOM; estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditHour))  { parametroAEditar = EDIT_HOUR; estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    else if (zoneNewPressed(&btn_EditMin))   { parametroAEditar = EDIT_MIN; estadoActual = ESTADO_TECLADO; bufferIdx = 0; keypadBuffer[0] = '\0'; dibujarTeclado(); }
                    break;
                
                case ESTADO_TECLADO:
                    for (j = 0; j < 12; j++) {
                        if (zoneNewPressed(&keys[j])) {
                            if (j < 9 || j == 10) { 
                                if (bufferIdx < 4) { keypadBuffer[bufferIdx] = (j == 10) ? '0' : (j + 1 + '0'); bufferIdx++; keypadBuffer[bufferIdx] = '\0'; dibujarTeclado(); }
                            } else if (j == 9) { estadoActual = ESTADO_AJUSTE_RTC; mostrarSeleccionRTC(); } 
                              else if (j == 11) { actualizarParametroRTC(); estadoActual = ESTADO_AJUSTE_RTC; mostrarSeleccionRTC(); }
                        }
                    }
                    break;
                
                case ESTADO_MODO_CONFIG:
                    if (zoneNewPressed(&btn_Volver)) { estadoActual = ESTADO_MENU_PRINCIPAL; mostrarMenuPrincipal(); }
                    else if (zoneNewPressed(&btn_servo_dec)) { if(anguloServo > 0) anguloServo-=5; update_screen=1; }
                    else if (zoneNewPressed(&btn_servo_inc)) { if(anguloServo < 180) anguloServo+=5; update_screen=1; }
                    else if (zoneNewPressed(&btn_brillo_dec)){ if(brilloDisplay > 0) brilloDisplay-=10; update_screen=1; }
                    else if (zoneNewPressed(&btn_brillo_inc)){ if(brilloDisplay < 100) brilloDisplay+=10; update_screen=1; }
                    else if (zoneNewPressed(&btn_GoVerdeConfig)) { ptr_audio_activo = audio_verde; estadoActual = ESTADO_CONFIG_VERDE; mostrarSubMenuColor("CONF VERDE", Green); }
                    else if (zoneNewPressed(&btn_GoNaranjaConfig)) { ptr_audio_activo = audio_Naranja; estadoActual = ESTADO_CONFIG_NARANJA; mostrarSubMenuColor("CONF NARANJA", Orange); }
                    
                    if(update_screen) {
                        LPC_PWM1->MR6 = (LPC_PWM1->MR0 * brilloDisplay) / 100; 
                        LPC_PWM1->LER |= (1<<6);
                        sprintf(texto, "Servo: %3d       ", anguloServo); 
                        disable_critical_irqs(); 
                        escribirTextoDinamico(zone_servo_val.x + 10, zone_servo_val.y + 7, texto, Black, White);
                        sprintf(texto, "Brillo: %3d%%     ", brilloDisplay); 
                        escribirTextoDinamico(zone_brillo_val.x + 10, zone_brillo_val.y + 7, texto, Black, White); 
                        enable_critical_irqs();
                        update_screen = 0; 
                    }
                    break;
                
                case ESTADO_CONFIG_VERDE:
                case ESTADO_CONFIG_NARANJA:
                    if (zoneNewPressed(&btn_Volver)) { estadoActual = ESTADO_MODO_CONFIG; mostrarModoConfig(); }
                    break;
            }
            pressedTouchPanel = 0; 
        }
    }
}
